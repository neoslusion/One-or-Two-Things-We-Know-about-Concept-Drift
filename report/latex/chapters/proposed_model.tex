\chapter{Mô hình đề xuất cho hệ thống phát hiện và thích ứng concept drift}

\section{Tổng quan kiến trúc hệ thống}

Hệ thống phát hiện và thích ứng concept drift được đề xuất trong luận văn này được xây dựng dựa trên kiến trúc streaming thời gian thực sử dụng Apache Kafka làm nền tảng xử lý luồng dữ liệu. Hệ thống bao gồm các thành phần chính như sau:

\subsection{Kiến trúc tổng thể}

Hệ thống được thiết kế theo mô hình pipeline với các thành phần độc lập giao tiếp qua Kafka message queue:

\begin{enumerate}
    \item \textbf{Producer (Bộ phát dữ liệu):} Tạo ra luồng dữ liệu liên tục với các điểm drift được kiểm soát, sử dụng hàm \texttt{gen\_random} để sinh dữ liệu tổng hợp.
    
    \item \textbf{Kafka Broker:} Quản lý hai topic chính:
    \begin{itemize}
        \item \texttt{sensor.stream}: Luồng dữ liệu đầu vào
        \item \texttt{drift.results}: Kết quả phát hiện drift
    \end{itemize}
    
    \item \textbf{Consumer - ShapeDD Detector:} Nhận dữ liệu từ Kafka, thực hiện phát hiện drift theo batch, và phân loại loại drift.
    
    \item \textbf{Adaptor (Bộ thích ứng mô hình):} Lắng nghe sự kiện drift, chọn chiến lược thích ứng phù hợp và cập nhật mô hình.
    
    \item \textbf{Real-time Visualization:} Hiển thị trực quan kết quả phát hiện và hiệu suất mô hình theo thời gian thực.
\end{enumerate}

\subsection{Luồng xử lý dữ liệu}

Quy trình xử lý dữ liệu trong hệ thống tuân theo các bước sau:

\begin{enumerate}
    \item Producer tạo dữ liệu với chỉ số drift (drift indicator) và gửi vào topic \texttt{sensor.stream}
    \item Consumer đọc dữ liệu, lưu vào buffer tuần hoàn (circular buffer) với kích thước cấu hình
    \item Khi đủ BUFFER\_SIZE mẫu, Consumer thực hiện phân tích ShapeDD trên toàn bộ batch
    \item Nếu phát hiện drift, hệ thống phân loại loại drift dựa trên phương pháp CDT\_MSW
    \item Kết quả phát hiện (bao gồm vị trí drift, p-value, loại drift) được ghi vào CSV và publish lên topic \texttt{drift.results}
    \item Adaptor nhận sự kiện drift, chọn chiến lược thích ứng dựa trên loại drift
    \item Mô hình được cập nhật và lưu lại cho inference tiếp theo
\end{enumerate}

\subsection{Cấu hình hệ thống}

Các tham số quan trọng của hệ thống:

\begin{table}[H]
\centering
\caption{Tham số cấu hình hệ thống}
\label{tab:system-config}
\begin{tabular}{lll}
\toprule
\textbf{Tham số} & \textbf{Giá trị} & \textbf{Ý nghĩa} \\
\midrule
BUFFER\_SIZE & 1000 & Số mẫu xử lý mỗi batch \\
CHUNK\_SIZE & 250 & Kích thước chunk cho phân tích drift \\
SHAPE\_L1 & 50 & Nửa cửa sổ cho ShapeDD \\
SHAPE\_L2 & 250 & Cửa sổ đầy đủ cho MMD \\
SHAPE\_N\_PERM & 2500 & Số lần hoán vị cho kiểm định \\
DRIFT\_PVALUE & 0.05 & Ngưỡng p-value phát hiện drift \\
\bottomrule
\end{tabular}
\end{table}

\section{Phương pháp ShapeDD - Phát hiện drift}

\subsection{Giới thiệu tổng quan} ShapeDD (Shape-based Drift Detector) là một phương pháp phát hiện trôi dạt khái niệm trong luồng dữ liệu, với mục tiêu chính là loại bỏ nhiễu (denoising) khỏi tín hiệu trôi dạt và xác định chính xác thời điểm xảy ra thay đổi. Trôi dạt khái niệm (concept drift) đề cập đến hiện tượng phân phối dữ liệu ẩn sau thay đổi theo thời gian, khiến mô hình học máy trở nên kém chính xác nếu không được điều chỉnh kịp thời. Nhiều phương pháp phát hiện trôi dạt không giám sát truyền thống dựa trên việc đo lường độ lệch giữa phân phối mẫu trong hai cửa sổ thời gian (ví dụ: cửa sổ hiện tại và cửa sổ tham chiếu). Tuy nhiên, do số lượng mẫu trong mỗi cửa sổ thường hạn chế, phép đo độ lệch này nhiễu đáng kể – khó phân biệt được sự khác biệt do drift thực sự gây ra so với dao động ngẫu nhiên bên trong phân phối. ShapeDD ra đời nhằm khắc phục nhược điểm này bằng cách lọc nhiễu khỏi tín hiệu drift dựa trên các tính chất hình dạng đặc trưng của tín hiệu khi xảy ra drift. Kết quả là phương pháp cung cấp một ước lượng độ lớn trôi dạt chính xác hơn so với ước lượng trực tiếp thông thường, đồng thời xác định rất chính xác thời điểm xảy ra sự kiện drift. Phương pháp đặc biệt hữu ích trong bối cảnh luồng dữ liệu liên tục (data streams) khi cần giám sát mô hình theo thời gian thực, giúp phát hiện kịp thời những thay đổi do môi trường (ví dụ: thay đổi mùa, nhu cầu người dùng thay đổi, sensor bị lão hóa, v.v.) gây ra.
\subsection{Nguyên lý hoạt động dựa trên hình dạng} Cốt lõi của ShapeDD nằm ở việc khai thác đặc trưng hình dạng của tín hiệu drift để nhận biết điểm thay đổi. Trước hết, phương pháp sử dụng khái niệm độ lớn trôi dạt $\sigma_{d,l}(t)$ (drift magnitude) được định nghĩa như sau: \begin{equation} \sigma_{d,l}(t) = d\Big(p_{[t-2l,t-l]},\,p_{[t-l,t]}\Big)\,, \label{eq:drift-magnitude} \end{equation} trong đó $p_{[a,b]}$ là phân phối dữ liệu trung bình trên đoạn thời gian $[a,b]$, và $d(\cdot,\cdot)$ là một độ đo khoảng cách giữa hai phân phối (ví dụ: khoảng cách Hellinger, độ lệch tổng, KL divergence, MMD). Trực quan, $\sigma_{d,l}(t)$ đo mức độ khác biệt giữa hai cửa sổ liên tiếp độ dài $l$ ngay trước thời điểm $t$; giá trị này khác 0 khi có trôi dạt xảy ra (phân phối thay đổi) và bằng 0 khi phân phối ổn định.
Khi xảy ra một drift đột ngột tại thời điểm $t_0$, độ lớn trôi dạt $\sigma(t)$ (bỏ chỉ số $d,l$ cho gọn) sẽ có hình dạng đặc trưng dạng “tam giác”: tăng lên rồi giảm xuống trong khoảng thời gian tương ứng với độ dài cửa sổ $l$. Cụ thể, với drift đột ngột thay đổi phân phối từ $P$ sang $Q$ tại $t_0=0$, lý thuyết chỉ ra rằng: \begin{equation} \sigma(t) \;=\; \lVert P - Q \rVert \cdot \max\left(0,\,1 - \frac{|\,l - t\,|}{\,l\,}\right)\,, \label{eq:triangle-shape} \end{equation} với $\lVert P - Q\rVert$ là độ lớn thay đổi phân phối (phụ thuộc vào độ đo lựa chọn) và phần hình dạng $h_l(t) = \max(0,\,1 - |l-t|/l)$ chỉ phụ thuộc vào $l$. Biểu thức \eqref{eq:triangle-shape} mô tả một “mũi nhọn” hình tam giác: $\sigma(t)$ bằng 0 ngoài khoảng $[0,2l]$, đạt cực đại (bằng $\lVert P-Q\rVert$) tại $t = l$ (tức là đúng một độ dài cửa sổ sau thời điểm drift), và thay đổi tuyến tính giữa 0 và đỉnh này. Nói cách khác, mọi drift đột ngột sinh ra một hình dạng chuẩn $h_l(t)$ trong đồ thị $\sigma(t)$, bất kể phân phối cụ thể $P, Q$ ra sao (chỉ ảnh hưởng đến độ cao $\lVert P-Q\rVert$).
Dựa trên nhận xét quan trọng đó, ShapeDD sử dụng biểu diễn hình dạng $h_l(t)$ như một mẫu chuẩn để nhận biết trôi dạt trong tín hiệu $\hat{\sigma}(t)$ thu được từ dữ liệu. Nguyên lý hoạt động gồm hai bước chính: (1) Khớp hình dạng (shape fitting) và (2) Phát hiện điểm đổi dấu của hàm shape. Ở bước (1), phương pháp cố gắng “ướm” một hàm dạng $h_l$ đã được dịch chuyển và co dãn theo trục $y$ vào chuỗi giá trị ước lượng $\hat{\sigma}(t)$ quan sát, nhằm tìm ra vị trí $t_0$ và biên độ $s$ sao cho $s \cdot h_l(t - t_0)$ khớp tốt nhất với $\hat{\sigma}(t)$. Việc ước lượng này thực hiện theo tiêu chí bình phương tối thiểu (least-squares), tương đương với tích chập $\hat{\sigma}$ với một bộ lọc hình dạng trọng số $h'_l(t)$ được định nghĩa như đạo hàm của $h_l$:
\begin{equation}
h'_l(t) = \begin{cases} 
1, & t \in [0, l) \\
-1, & t \in (l, 2l] \\
0, & \text{ngoài } [0,2l]
\end{cases}
\end{equation}
Bộ lọc $h'_l$ này lấy giá trị $+1$ trên nửa đầu cửa sổ và $-1$ trên nửa sau, thực chất đóng vai trò tính hiệu hiệu độ lệch giữa hai nửa cửa sổ (trước và sau drift). Khi tích chập $\hat{\sigma}(t)$ với $h'_l$, tại vùng quanh một sự kiện drift thật, kết quả sẽ tạo thành một hàm hình dạng có đoạn dương rồi đoạn âm; đặc biệt, thời điểm đổi dấu từ dương sang âm của kết quả tích chập chính là ứng viên vị trí drift $t_0$ cần tìm. Do đó, ở bước (2), ShapeDD dò tìm các vị trí mà giá trị tích chập $(\hat{\sigma} * h'_l)(t)$ đổi từ dương sang âm – đó chính là những điểm khả nghi xảy ra thay đổi phân phối. Mỗi vị trí ứng viên $t_0$ như vậy tương ứng với một hàm $h_l$ dịch chuyển, và hệ số nhân $s$ (biên độ) được tính dễ dàng theo công thức đóng (tỉ lệ với tích chập $\hat{\sigma}$ và $h_l$ tại $t_0$).
Nhờ việc khớp hàm dạng tham số $h_l$, chuỗi tín hiệu drift được “nén” lại chỉ còn vài tham số ($t_0$ và $s$ cho mỗi sự kiện drift) thay vì toàn bộ giá trị tại mỗi thời điểm, do đó giảm thiểu ảnh hưởng của nhiễu dao động cục bộ. Thực tế, $\tilde{\sigma}(t)$ (tín hiệu drift sau khi khử nhiễu bằng hàm shape) sẽ “ít dích dắc” (ít dao động nhỏ) hơn hẳn so với $\hat{\sigma}(t)$ ban đầu, và có phương sai điểm thấp hơn do chỉ được mô tả bằng một dạng hình học cố định. Điều này giúp phân biệt rõ ràng hơn đâu là dao động do nhiễu và đâu là biến động do drift thật sự gây ra.
\subsection{Cấu trúc kỹ thuật và pipeline xử lý} Pipeline triển khai của ShapeDD gồm các bước chính sau đây:
	Tính toán độ lệch phân phối liên tục: Từ luồng dữ liệu, tại mỗi thời điểm $t$ phương pháp cập nhật độ lớn trôi dạt $\hat{\sigma}(t)$ giữa hai cửa sổ độ dài $l$ ngay trước $t$ (theo công thức \eqref{eq:drift-magnitude}). Khoảng cách $d$ sử dụng trong ShapeDD có thể tùy chọn; trong bài báo gốc, tác giả chọn khoảng cách Maximum Mean Discrepancy (MMD) với kernel Gauss do tính ưu việt của nó (là một metric trên không gian phân phối, không phụ thuộc số chiều dữ liệu). MMD được ước lượng một cách cập nhật mỗi khi cửa sổ trượt, với chi phí tính toán $O(l^2)$ cho lần đầu và $O(l)$ cho mỗi bước cập nhật (nhờ tận dụng tính chất tích lũy của công thức kernel). Thông thường, $l$ (độ dài cửa sổ) được chọn cố định dựa theo kiến thức về dữ liệu hoặc thông qua thử nghiệm. ShapeDD cũng cho phép sử dụng nhiều độ dài cửa sổ song song để tăng tính robust, nhằm tránh bỏ sót drift nếu chọn sai một giá trị $l$ duy nhất. Trên thực tế, tác giả khuyến nghị kết hợp $N$ phiên bản $\hat{\sigma}_i(t)$ với các $l_i$ khác nhau (và thậm chí các độ đo $d$ khác nhau) để tận dụng nhiều quy mô thời gian của drift. Những tín hiệu này sẽ được xử lý đồng thời trong bước tiếp theo.
	Lọc tín hiệu bằng hàm shape: Tín hiệu $\hat{\sigma}(t)$ (hoặc các $\hat{\sigma}_i(t)$ nếu dùng đa cửa sổ) được tích chập với bộ lọc trọng số $h'_l$ (đã nêu ở phần trên) nhằm phát hiện mẫu hình dạng tam giác đặc trưng. Kết quả tích chập thực chất tương ứng với đạo hàm của hàm mất mát khớp shape (hàm \eqref{eq:triangle-shape}) theo tham số $t_0$. Nhờ đó, việc tìm $t_0$ tối ưu giảm thành tìm điểm mà tích chập đổi dấu từ dương sang âm (tương ứng $\frac{\partial L}{\partial t_0} = 0$). Thuật toán thực hiện quét một lượt các giá trị thời gian và ghi nhận những nơi xảy ra chuyển dấu này. Do dữ liệu thời gian rời rạc, để tránh bỏ lỡ trường hợp zero-crossing nằm giữa hai thời điểm lấy mẫu, ShapeDD chỉ cần kiểm tra sự thay đổi dấu giữa các bước liền kề của chuỗi tích chập. Mỗi lần phát hiện chuyển dấu dương$\to$âm, ta xác định được một ứng viên drift tại thời điểm $t_0$. Đây chính là bước phát hiện drift sơ bộ. Lưu ý rằng nếu sử dụng nhiều tín hiệu $\hat{\sigma}_i$ (nhiều $l_i$), ShapeDD gán chung một tham số $t_0$ cho tất cả và giải đồng thời (theo nghĩa tối ưu tổng bình phương) nên các $\hat{\sigma}_i$ sẽ cùng cho một điểm drift thống nhất. Trong trường hợp đơn giản dùng một độ dài cửa sổ, các tham số biên độ $s_i$ sẽ triệt tiêu trong phương trình tối ưu và ta có thể xác định $t_0$ độc lập trước, sau đó mới tính các $s_i$ tương ứng.
	Xác nhận drift và khử nhiễu: Không phải mọi điểm chuyển dấu đều tương ứng drift thật; một số có thể do nhiễu gây ra khớp shape giả. Vì vậy, ShapeDD áp dụng bước xác nhận: tại mỗi $t_0$ ứng viên, tính biên độ $s_i$ cho các shape khớp (theo công thức nội suy như \eqref{eq:triangle-shape} hoặc \eqref{eq:triangle-shape} tích chập, ví dụ công thức (2) trong bài báo), rồi so sánh $s_i$ (hoặc trung bình $s$ chung) với một ngưỡng tối thiểu để lọc bỏ các drift quá nhỏ không đáng kể. Quan trọng hơn, ShapeDD tiến hành một kiểm định thống kê để xác nhận phân phối thực sự thay đổi tại $t_0$. Cụ thể, phương pháp sử dụng phép kiểm định hai mẫu (ví dụ: MMD two-sample test) giữa hai cửa sổ trước và sau $t_0$ đó. Kiểm định này đóng vai trò như một bộ phân loại phân biệt xem hai tập dữ liệu thuộc hai cửa sổ có đến từ cùng một phân phối hay không. Chỉ khi phép kiểm định cho kết quả có ý nghĩa thống kê (ví dụ $p$-value nhỏ hơn ngưỡng) thì $t_0$ mới được xác nhận là drift thực sự và phát tín hiệu cảnh báo. Nhờ cách tiếp cận này, các khớp shape ngẫu nhiên do nhiễu sẽ bị loại bỏ nếu không vượt qua được phép kiểm định. Cuối cùng, sau khi xác nhận, ShapeDD trả ra thời điểm xảy ra drift với độ chính xác cao (có thể hiệu chỉnh độ trễ $l$ nếu cần để khớp đúng thời điểm thay đổi đột ngột ban đầu). Trong quá trình xử lý luồng, phương pháp vận hành theo thời gian thực với độ phức tạp tổng thể $\mathcal{O}(l)$ trên mỗi mẫu mới cập nhật, nhờ đó thích hợp cho các ứng dụng đòi hỏi tốc độ cao.
Các tham số chính của ShapeDD bao gồm: độ dài cửa sổ $l$ (hoặc tập các $l$), hàm kernel cho MMD (ví dụ kernel Gaussian và băng thông tương ứng), mức ý nghĩa $\alpha$ cho kiểm định drift, và ngưỡng biên độ $s$ tối thiểu. Những tham số này thường được chọn dựa trên đặc thù bài toán hoặc tối ưu dựa trên các phép đo hiệu năng (ví dụ $\beta$-score, xem phần sau).
\subsection{Ưu điểm nổi bật của ShapeDD} ShapeDD mang lại một số ưu điểm quan trọng so với các phương pháp phát hiện trôi dạt truyền thống:
	Khử nhiễu và giảm báo động giả: Nhờ cơ chế lọc shape, ShapeDD giảm đáng kể số lần báo động sai do nhiễu thống kê. Thay vì phản ứng với mọi dao động nhỏ trong tín hiệu, phương pháp chỉ tập trung vào các biến động có hình dạng phù hợp với một sự kiện drift thật. Kết quả thực nghiệm cho thấy ShapeDD có tỷ lệ false alarm rất thấp so với các phương pháp khác. Thậm chí, so với phương pháp dùng trực tiếp MMD tại mọi thời điểm (không lọc shape), ShapeDD giảm trung bình khoảng 20 lần báo động giả trên các tập dữ liệu kiểm thử. Điều này chứng tỏ tính ổn định vượt trội của phương pháp trong môi trường nhiều nhiễu.
	Độ chính xác định vị cao: ShapeDD có khả năng xác định chính xác thời điểm xảy ra drift. Nhờ việc khớp dạng tam giác, phương pháp định vị điểm thay đổi gần như trùng khớp với vị trí drift thực (sai lệch chỉ khoảng $\pm l$ hoặc ít hơn, có thể hiệu chỉnh). Trong khi nhiều phương pháp cửa sổ đôi khác chỉ báo động đang có drift trong một khoảng nào đó, ShapeDD cung cấp trực tiếp thời điểm trôi dạt với độ trễ rất nhỏ. Điều này hữu ích để kịp thời kích hoạt cơ chế tái huấn luyện mô hình đúng lúc cần thiết.
	Hiệu suất phát hiện cao: Trên các bộ dữ liệu chuẩn (như SEA, STAGGER, Hyperplane, v.v.) và dữ liệu thực tế, ShapeDD đạt hiệu năng phát hiện drift tương đương hoặc cao hơn các thuật toán đầu bảng. Chỉ số $\beta$-score (tỷ lệ TP/FP có trọng số) của ShapeDD thường vượt trội so với phương pháp so sánh, trừ một vài trường hợp đặc thù ngang ngửa HDDM. Đặc biệt, ShapeDD luôn vượt hơn phương pháp MMD thô (dùng cùng metric) và phương pháp drift magnitude truyền thống (DM) về mọi mặt. Dù phương pháp MMD thuần có nhỉnh hơn về xác suất phát hiện trong cửa sổ rất nhỏ, ShapeDD vẫn giữ vững ưu thế khi cửa sổ lớn hơn, đồng thời tránh được hiện tượng báo sai hàng loạt của MMD khi nhiễu nhiều. Nhìn chung, ShapeDD được đánh giá là một giải pháp phát hiện drift tin cậy, với khả năng định vị rất chính xác và hầu như không bỏ sót sự kiện drift nào quan trọng.
	Thích ứng với nhiều kịch bản drift: Mặc dù giả định lý thuyết ban đầu tập trung vào drift đột ngột, ShapeDD trong thực nghiệm tỏ ra linh hoạt trước nhiều kiểu trôi dạt khác nhau. Nhờ việc có thể kết hợp nhiều độ dài cửa sổ và nhiều độ đo, phương pháp có thể bắt được cả những thay đổi nhanh lẫn chậm. Trong trường hợp drift diễn ra dần dần, tín hiệu $\hat{\sigma}(t)$ sẽ có biên độ nhỏ trải dài hơn, nhưng ShapeDD vẫn có thể phát hiện khi đủ tích lũy thành một “đốm” hình dạng gần tam giác (dù kéo dài) và sẽ báo động với độ trễ nhất định. Ngoài ra, shapeDD thừa hưởng tính chất phát hiện chắc chắn (surely detecting) từ định nghĩa drift magnitude: nếu trôi dạt đủ rõ ràng và tách biệt, phương pháp đảm bảo sẽ phát hiện (với xác suất kiểm định cho trước) nhờ tính hợp lệ thống kê của phép kiểm định kernel two-sample.
	Tính toán hiệu quả: Thuật toán ShapeDD được triển khai tối ưu để chạy online với chi phí tuyến tính theo kích thước cửa sổ trên mỗi mẫu mới, tức chi phí không tăng theo thời gian chạy. Việc tận dụng tích chập qua cumulative sum giúp tìm điểm drift trong một lượt quét mà không cần thuật toán tối ưu phức tạp lặp đi lặp lại. So với nhiều phương pháp drift detection khác có độ phức tạp tương đương hoặc cao hơn, ShapeDD đủ nhẹ để áp dụng trong thời gian thực trên luồng dữ liệu tốc độ cao.

\subsection{Hạn chế và điều kiện áp dụng hiệu quả} Bên cạnh ưu điểm, ShapeDD cũng có một số hạn chế và điều kiện cần lưu ý để phương pháp hoạt động hiệu quả:
•	Giả định drift rời rạc và đột ngột: Lý thuyết hình dạng của ShapeDD giả định mỗi khoảng thời gian chỉ có tối đa một sự kiện drift rõ ràng. Nếu các drift xảy ra liên tục hoặc quá gần nhau (khoảng cách giữa hai lần thay đổi nhỏ hơn độ dài $2l$ của cửa sổ), các mẫu hình tam giác có thể chồng lấn khiến bộ lọc shape không còn nhận dạng đúng được. Trong trường hợp có nhiều drift liên tiếp sát nhau, phương pháp có thể bỏ sót hoặc xác định sai thời điểm. Do đó, ShapeDD phù hợp nhất khi các thay đổi lớn diễn ra cách nhau một khoảng đủ dài so với $l$ (ví dụ dữ liệu ít nhất “ổn định” trong khoảng $2l$ giữa các lần chuyển pha). Nếu không đảm bảo được điều này, ta nên giảm độ dài cửa sổ hoặc dùng nhiều cửa sổ song song để tăng khả năng bắt được các drift gần nhau.
•	Hạn chế với drift liên tục (gradual drift): Trong trường hợp concept drift xảy ra một cách từ từ liên tục (ví dụ mô hình trôi nhẹ dần theo thời gian không có điểm cắt rạch ròi), hình dạng “tam giác” đặc trưng sẽ không còn rõ nét. Thực tế chỉ ra rằng hình dạng đặc trưng mà ShapeDD khai thác là một hiệu ứng của drift đột ngột tương tác với cửa sổ trượt; nếu phân phối thay đổi dần, tín hiệu $\sigma(t)$ sẽ không tạo thành mũi nhọn mà có thể chỉ nhô lên rất thoải. Khi đó, cách tiếp cận shape có thể kém nhạy hoặc phải đợi đến khi đủ lớn mới báo (dẫn tới trễ). Để áp dụng hiệu quả trong tình huống này, người ta có thể cần điều chỉnh chiến lược cửa sổ (ví dụ tăng dần kích thước cửa sổ để tích lũy sự khác biệt) hoặc sử dụng các meta-statistics phức tạp hơn phân tích toàn bộ đoạn dữ liệu thay vì chỉ hai cửa sổ. Tóm lại, ShapeDD phát huy tốt nhất với các drift kiểu đột ngột hoặc giai đoạn (sudden/step or piecewise constant drift), còn với drift trơn liên tục thì có thể cần kết hợp thêm kỹ thuật khác để nhận biết sớm.
•	Lựa chọn độ dài cửa sổ $l$: Hiệu quả của ShapeDD phụ thuộc vào tham số $l$. Nếu $l$ quá nhỏ, ước lượng $\hat{\sigma}(t)$ rất nhiễu, khiến khớp shape khó phân biệt tín hiệu; ngược lại nếu $l$ quá lớn, hiệu ứng drift bị làm mờ và còn gây tăng độ trễ phát hiện. Trong một số trường hợp xấu, lựa chọn $l$ không phù hợp có thể làm trôi dạt bị bỏ lọt: ví dụ nếu dữ liệu thay đổi tuần hoàn với chu kỳ đúng bằng $l$ thì cửa sổ trước-sau luôn chứa phân phối tương tự và $\sigma(t)=0$ liên tục. Do đó, để áp dụng hiệu quả, cần chọn $l$ dựa trên hiểu biết về chu kỳ/nhịp thay đổi của dữ liệu. Một giải pháp an toàn là kết hợp nhiều $l$ như ShapeDD đề xuất sẵn, nhằm đảm bảo không bỏ sót trong trường hợp $l$ trùng chu kỳ lặp như ví dụ trên. Tuy nhiên, việc dùng nhiều cửa sổ cũng làm tăng chi phí tính toán và độ phức tạp triển khai.
•	Tham số kiểm định và ngưỡng: ShapeDD yêu cầu đặt ngưỡng cho kiểm định (mức ý nghĩa $\alpha$) và ngưỡng cho biên độ $s$. Nếu đặt ngưỡng quá cao (nghiêm ngặt), phương pháp có thể bỏ lỡ những drift nhẹ; nếu đặt quá thấp, sẽ tăng nguy cơ báo động giả. Việc chọn các ngưỡng này cần hiệu chỉnh cẩn thận, thường thông qua cross-validation hoặc dựa vào chỉ số đánh giá tổng hợp như $\beta$-score.
•	Trường hợp dữ liệu nhiều chiều phức tạp: Mặc dù MMD với kernel Gauss có ưu điểm không phụ thuộc số chiều, nhưng trong thực tế khi phân phối thay đổi chỉ trên một phần không gian đặc trưng, hoặc drift chỉ ảnh hưởng một vài thuộc tính, thì việc phát hiện có thể khó khăn hơn (tín hiệu drift yếu vì khoảng cách toàn cục nhỏ). Khi đó, có thể cần kết hợp ShapeDD với phương pháp lựa chọn đặc trưng hoặc kiểm định theo từng chiều để khoanh vùng drift tốt hơn.
Tóm lại, để ShapeDD hoạt động hiệu quả, cần đảm bảo giả định cửa sổ trượt hợp lý (drift đủ tách biệt trong khoảng $2l$) và điều chỉnh tham số phù hợp với bản chất dữ liệu. Trong phạm vi đó, phương pháp sẽ cho kết quả tin cậy; còn ngoài phạm vi, có thể xem xét mở rộng hoặc kết hợp thêm phương pháp khác (như đề xuất trong các nghiên cứu mới hơn) để bao quát trường hợp khó.
\subsection{Thuật toán chi tiết của ShapeDD} Pseudo-code rút gọn của thuật toán ShapeDD cho một luồng dữ liệu (sử dụng một độ đo $d$ và một độ dài cửa sổ $l$ cố định) có thể mô tả như sau:
\begin{itemize} \item \textbf{Khởi tạo:} Đặt $W_1$ và $W_2$ là hai cửa sổ dữ liệu (rỗng ban đầu) kích thước $l$. Khi bắt đầu, thu thập $2l$ điểm dữ liệu đầu tiên để lấp đầy $W_1$ và $W_2$ (mỗi cửa sổ $l$ điểm). Tính toán $\hat{\sigma}(2l) = d(W_1, W_2)$ làm giá trị độ lớn drift tại thời điểm $t = 2l$. \item \textbf{Cập nhật trượt:} Với mỗi mẫu dữ liệu mới đến ở thời điểm $t+1$: \begin{enumerate} \item Đẩy mẫu mới vào cửa sổ $W_2$, đồng thời bỏ mẫu cũ nhất khỏi $W_1$ (cửa sổ trước) và chuyển cửa sổ $W_2$ cũ thành $W_1$ (tức trượt cửa sổ). Kết quả: $W_1$ chứa dữ liệu từ $t-l+1$ đến $t$, $W_2$ chứa dữ liệu từ $t+1-l+1$ đến $t+1$. \item Tính $\hat{\sigma}(t+1) = d(W_1, W_2)$ – độ lệch giữa hai cửa sổ mới. \item Tính giá trị tích chập $g(t+1) = (\hat{\sigma} * h'l)(t+1)$, với $h'_l$ như định nghĩa ở trên. Việc này có thể làm hiệu quả bằng cách cập nhật từ $g(t)$ thay vì tính lại toàn bộ tích chập (do $h'_l$ chỉ có 3 đoạn giá trị). \item \textbf{Kiểm tra shape:} Nếu $g(t)$ dương và $g(t+1)$ âm (hoặc $g(t)$ bằng 0 và $g(t+1)$ âm): ta phát hiện một điểm chuyển dấu dương-sang-âm tại khoảng thời gian $t \sim t+1$. Gọi $\hat{t}_0 = t+1$ là thời điểm nghi ngờ xảy ra drift. \item \textbf{Xác nhận drift:} Khi phát hiện $\hat{t}_0$: \begin{enumerate} \item Tính các hệ số $s$ khớp hàm shape: $s = \frac{3}{2l}\sum_{\tau=\hat{t}_0-2l}^{\hat{t}_0} \hat{\sigma}(\tau)\,h_l(\tau - \hat{t}_0)$ (theo công thức nội suy lý thuyết, hoặc sử dụng trực tiếp kết quả tích chập). \item Kiểm tra $s$ so với ngưỡng $s_0$ (coi như nhiễu nhỏ). Ngược lại nếu $s$ đủ lớn, thực hiện tiếp kiểm định. \item Thực hiện kiểm định hai phân phối trên $W_1$ và $W_2$ tại $\hat{t}_0$ (ví dụ: kiểm định MMD với hoán vị, hoặc kiểm định Hellinger) với mức ý nghĩa $\alpha$. Nếu kết quả không có ý nghĩa thống kê (p-value lớn), thì loại bỏ $\hat{t}_0$ (xác suất cao là báo động giả do khớp ngẫu nhiên). Nếu kết quả có ý nghĩa (p-value nhỏ hơn $\alpha$), thì xác nhận drift: thông báo xảy ra drift tại thời điểm $\hat{t}_0 - \delta$ (trong đó $\delta$ có thể là hiệu chỉnh độ trễ, thường $\delta \approx l/2$ nếu muốn ước lượng thời điểm thay đổi thật). \end{enumerate} \item Quay lại bước (a) cho mẫu kế tiếp. \end{enumerate} \end{itemize}
Trong thuật toán trên, $\delta$ là một hiệu chỉnh nhỏ do đỉnh của $h_l$ lệch $+l$ sau drift. Trên thực tế, ShapeDD có thể thông báo luôn tại $\hat{t}_0$ như là điểm giữa mà hai cửa sổ khác nhau nhiều nhất; do drift đột ngột thường xảy ra khoảng giữa hai cửa sổ đó, ta có thể coi $\hat{t}_0 - l$ là thời điểm thay đổi thực sự. Dù vậy, do $l$ khá nhỏ so với toàn bộ dữ liệu, việc lệch một khoảng $l$ không ảnh hưởng nhiều đến độ chính xác chung trong các ứng dụng thực tế.
Pseudo-code trên có thể mở rộng dễ dàng cho trường hợp đa cửa sổ ($l_1,...,l_N$) bằng cách duy trì $N$ cặp cửa sổ song song và $N$ giá trị $\hat{\sigma}i(t)$ tương ứng. Khi đó tích chập $g(t)$ sẽ là tổng tích chập của từng $\hat{\sigma}_i$ với $h'$ và ngưỡng $s$ cũng sẽ tính gộp chung (theo công thức (2) trong bài báo). Tư tưởng chung vẫn là: tìm điểm $t_0$ tối ưu sao cho toàn bộ các tín hiệu $\hat{\sigma}_i$ đều khớp đồng thời với một họ hàm shape được dịch chuyển (cùng $t_0$ nhưng $l_i$ khác nhau). Điều này giúp tăng độ tin cậy của phát hiện drift khi các thang đo đều đồng thuận.
\subsection{So sánh ShapeDD với các phương pháp phát hiện trôi dạt khác} ShapeDD vs. DDM: DDM (Drift Detection Method của Gama, 2004) là phương pháp giám sát lỗi phân loại theo thời gian và đưa ra cảnh báo drift khi tỷ lệ lỗi tăng vượt ngưỡng dựa trên mô hình Bernoulli. So với DDM, ShapeDD có một số khác biệt lớn: (1) ShapeDD hoạt động không cần nhãn (unsupervised), trực tiếp phát hiện thay đổi phân phối dữ liệu thay vì chờ sai số mô hình tăng. Do đó, ShapeDD có thể áp dụng cả khi không có dòng nhãn liên tục, trong khi DDM chỉ hữu dụng trong bối cảnh giám sát (supervised) và phụ thuộc vào chất lượng mô hình hiện tại. (2) Về độ chính xác thời gian, ShapeDD thường xác định điểm drift nhanh và chính xác hơn. DDM có xu hướng phát hiện muộn – nó đợi đủ bằng chứng sai số tăng mới kích hoạt, dẫn đến độ trễ nhất định sau khi drift xảy ra. Ngược lại, ShapeDD phản ứng ngay khi phân phối bắt đầu lệch, và nhờ đặc trưng shape, nó nhận biết gần như đồng thời với lúc thay đổi (chỉ lệch khoảng nửa độ dài cửa sổ $l$). (3) Về độ nhạy và nhiễu, DDM có thể nhạy cảm với các dao động ngẫu nhiên trong lỗi (false alarm nếu mô hình tạm thời xấu đi do may mắn ngẫu nhiên), nhưng cũng có thể bỏ lỡ những drift nhỏ kéo dài (vì sai số tăng chậm). ShapeDD khắc phục được nhiều vấn đề này do lọc nhiễu và không phụ thuộc trực tiếp vào hiệu năng mô hình. Tuy nhiên, DDM rất đơn giản và nhẹ, trong khi ShapeDD phức tạp hơn và cần tính khoảng cách phân phối liên tục. Tổng hợp lại, ShapeDD thích hợp cho các hệ thống không giám sát hoặc muốn phát hiện sớm tại nguồn dữ liệu, còn DDM phù hợp như một lớp giám sát hiệu suất mô hình hậu kỳ trong bài toán phân loại.
ShapeDD vs. ADWIN: ADWIN (Adaptive Windowing, Bifet \& Gavalda 2007) là phương pháp dựa trên trượt cửa sổ với kích thước thay đổi thích ứng. ADWIN luôn duy trì một cửa sổ dữ liệu có thể mở rộng, và thu hẹp lại khi kiểm định thống kê phát hiện phân phối ở đầu và cuối cửa sổ khác nhau đáng kể. Cả ADWIN và ShapeDD đều sử dụng kiểm định thống kê trên cửa sổ dữ liệu, nhưng cách tiếp cận khác nhau: ADWIN liên tục thử cắt cửa sổ hiện tại thành hai đoạn để tìm điểm cắt tối ưu (nếu chênh lệch trung bình hai đoạn vượt ngưỡng thì tách cửa sổ, báo drift), còn ShapeDD dùng hai cửa sổ cố định độ dài $l$ và nhận dạng mẫu hình dạng trong chuỗi kết quả so sánh. Ưu điểm của ShapeDD so với ADWIN là giảm thiểu kiểm định nhiều lần: ADWIN phải kiểm tra rất nhiều điểm cắt có thể trong cửa sổ lớn, dễ gặp vấn đề nhiều kiểm định (multiple testing) làm tăng xác suất báo sai, trong khi ShapeDD chỉ xem xét vài điểm ứng viên do shape filter chọn lọc (thường các ứng viên này cách xa nhau). Do đó ShapeDD giảm hẳn nguy cơ báo trùng lặp hoặc báo giả liên tục khi cửa sổ lớn. Bên cạnh đó, ShapeDD cho phép định vị chính xác điểm drift (vì cung cấp trực tiếp $t_0$), còn ADWIN thường chỉ biết “một thay đổi đã xảy ra” và phải ước lượng điểm cắt – độ chính xác có thể kém hơn nếu thay đổi xảy ra gần biên cửa sổ. Về khả năng thích ứng, ADWIN nổi bật trong xử lý drift dần dần: nó có thể từ từ thu hẹp/gia tăng cửa sổ để phản ứng với thay đổi chậm, trong khi ShapeDD như đã nêu có thể cần tinh chỉnh để bắt drift từ từ. Mặt khác, trong tình huống drift đột ngột, ADWIN thường phải chờ tích lũy đủ bằng chứng để co cửa sổ, nên có thể trễ hơn ShapeDD chút ít. Về độ phức tạp, ADWIN trung bình $O(n)$ mỗi mẫu (với $n$ là độ dài cửa sổ hiện tại) – đôi khi có thể cao khi cửa sổ mở rộng rất lớn, nhưng nó có thủ thuật giảm chi phí; ShapeDD cố định $O(l)$ nên kiểm soát được tốt thời gian chạy. Tóm lại, ADWIN linh hoạt và đơn giản hơn trong cài đặt, nhưng ShapeDD vượt trội ở chỗ lọc nhiễu thông minh và chỉ báo động khi thấy “hình dạng drift” rõ ràng, nhờ đó duy trì được độ chính xác cao và rất ít báo động giả ngay cả khi dữ liệu nhiễu nặng.
ShapeDD vs. các phương pháp khác: Trong phạm vi phát hiện drift không giám sát, ngoài ADWIN còn có nhiều phương pháp như: HDDM (Hellinger Distance Drift Detection) sử dụng khoảng cách Hellinger tích lũy, phương pháp kiểm định phân phối (KS-test, Page-Hinkley), hay các tiếp cận dựa trên phân cụm, trên phân tích thành phần chính, v.v. So với các phương pháp này, điểm độc đáo của ShapeDD là khai thác cấu trúc hình dạng lý thuyết của tín hiệu drift – một khía cạnh mà hầu hết phương pháp khác chưa tận dụng. Nhờ đó, ShapeDD đạt được cân bằng tốt giữa độ nhạy và độ đặc hiệu: nhạy vì nó dùng các độ đo mạnh như MMD, đặc hiệu vì nó yêu cầu khuôn dạng đặc trưng mới báo động. Kết quả so sánh với HDDM cho thấy ShapeDD thường cho $\beta$-score cao hơn, đặc biệt trong trường hợp nhiễu lớn (HDDM có thể báo nhiều false positive hơn). Tuy nhiên, HDDM trong một số trường hợp phát hiện được drift nhỏ tốt hơn (vì tích lũy dần dần), dẫn đến xác suất phát hiện nhỉnh hơn khi cửa sổ rất nhỏ. Dù vậy, trên tổng thể nhiều bộ dữ liệu, ShapeDD được đánh giá cao nhờ ổn định và chính xác, đặc biệt là về phương diện giảm thiểu báo động sai và định vị đúng thời điểm thay đổi.
Một so sánh khái quát: nếu DDM, EDDM, Page-Hinkley,... là các phương pháp đơn giản, lấy thay đổi của một thống kê (lỗi trung bình, trung bình trượt, v.v.) làm tín hiệu drift, thì ShapeDD là phương pháp bậc cao hơn khi trực tiếp phân tích dạng của tín hiệu drift đó. Điều này giống như so sánh việc nhìn mức nước sông dâng cao bất thường (phương pháp truyền thống) với việc nhận ra hình dạng đặc trưng của một cơn sóng thần trong biến động mực nước (ShapeDD) – rõ ràng cách sau đáng tin cậy hơn trong việc báo động đúng sự kiện đặc thù. Nhược điểm là ShapeDD phức tạp hơn và đòi hỏi hiểu biết lý thuyết để triển khai, nhưng lợi ích mang lại rất lớn trong các hệ thống giám sát thay đổi nơi ta cần hành động chính xác, kịp thời và đáng tin cậy. Các kết quả nghiên cứu đã chứng minh ShapeDD là một đóng góp quan trọng, kết hợp giữa nền tảng lý thuyết vững chắc về phân phối và tính ứng dụng thực tiễn trong xử lý luồng dữ liệu~\cite{shapeDD2024,hinder2024survey_partA}.

\subsection{Cải tiến thích ứng dựa trên SNR: ShapeDD SNR-Adaptive}

\subsubsection{Phát hiện quan trọng: Ảnh hưởng của tỷ lệ tín hiệu-nhiễu (SNR)}

Qua quá trình thử nghiệm và đánh giá với nhiều tập dữ liệu khác nhau, chúng tôi phát hiện ra một kết quả quan trọng: \textbf{không có chiến lược phát hiện drift duy nhất là tối ưu cho mọi môi trường SNR}.

Kết quả thực nghiệm cho thấy:

\textbf{Môi trường SNR cao} (tín hiệu drift mạnh, nhiễu thấp):
\begin{itemize}
    \item Phương pháp ShapeDD\_Adaptive\_v2 với ngưỡng tích cực (aggressive) đạt hiệu suất cao nhất
    \item Đạt recall cao bằng cách phát hiện được tất cả các sự kiện drift với ít báo động giả
    \item Ví dụ: enhanced\_sea (F1=0.947), stagger (F1=0.952)
\end{itemize}

\textbf{Môi trường SNR thấp} (tín hiệu drift yếu, nhiễu cao):
\begin{itemize}
    \item Phương pháp ShapeDD gốc với ngưỡng bảo thủ (conservative) vượt trội
    \item Đạt precision cao bằng cách chờ tín hiệu rõ ràng vượt ngưỡng nhiễu
    \item Ví dụ: gen\_random\_mild (F1=0.842), gen\_random\_moderate (F1=0.900)
\end{itemize}

\subsubsection{Nền tảng lý thuyết: Lý thuyết phát hiện tín hiệu}

Kết quả này phản ánh một nguyên lý cơ bản trong lý thuyết phát hiện tín hiệu (Signal Detection Theory) và tiêu chuẩn Neyman-Pearson:

\begin{equation}
\text{SNR} = \frac{\sigma^2_{\text{signal}}}{\sigma^2_{\text{noise}}}
\end{equation}

trong đó:
\begin{itemize}
    \item $\sigma^2_{\text{signal}}$: phương sai của tín hiệu drift (độ biến thiên giữa các cửa sổ)
    \item $\sigma^2_{\text{noise}}$: phương sai nhiễu nội tại trong dữ liệu
\end{itemize}

\textbf{Đánh đổi Precision-Recall theo SNR:}

\begin{itemize}
    \item \textbf{Ngưỡng tích cực (thấp):}
    \begin{itemize}
        \item Recall cao (phát hiện nhiều drift)
        \item Nguy cơ báo động giả trên nhiễu (False Positive tăng)
        \item Phù hợp khi SNR cao
    \end{itemize}

    \item \textbf{Ngưỡng bảo thủ (cao):}
    \begin{itemize}
        \item Precision cao (ít báo động giả)
        \item Nguy cơ bỏ lỡ tín hiệu yếu (False Negative tăng)
        \item Phù hợp khi SNR thấp
    \end{itemize}
\end{itemize}

\subsubsection{Giải pháp: Phương pháp hybrid thích ứng SNR}

Để khắc phục hạn chế của các chiến lược đơn lẻ, chúng tôi đề xuất phương pháp \textbf{ShapeDD SNR-Adaptive} - một thuật toán hybrid tự động chọn chiến lược phát hiện dựa trên SNR ước lượng của môi trường:

\textbf{Thuật toán ước lượng SNR:}

\begin{algorithm}[H]
\caption{Ước lượng SNR từ luồng dữ liệu}
\begin{algorithmic}[1]
\REQUIRE Dữ liệu $X$, kích thước cửa sổ $w$, số mẫu $k$
\ENSURE Ước lượng SNR
\STATE Chia $X$ thành $k$ cửa sổ kích thước $w$
\STATE Tính trung bình mỗi cửa sổ: $\mu_1, \mu_2, ..., \mu_k$
\STATE Tính phương sai giữa các cửa sổ: $\sigma^2_{\text{signal}} = \text{Var}(\mu_1, ..., \mu_k)$
\STATE Tính phương sai trung bình trong mỗi cửa sổ: $\sigma^2_{\text{noise}} = \frac{1}{k}\sum_{i=1}^{k}\text{Var}(X_i)$
\RETURN $\text{SNR} = \frac{\sigma^2_{\text{signal}}}{\sigma^2_{\text{noise}}}$
\end{algorithmic}
\end{algorithm}

\textbf{Logic lựa chọn chiến lược:}

\begin{algorithm}[H]
\caption{ShapeDD SNR-Adaptive}
\begin{algorithmic}[1]
\REQUIRE Dữ liệu $X$, ngưỡng SNR $\tau$, độ nhạy $s$
\ENSURE Kết quả phát hiện drift
\STATE $\text{SNR}_{\text{est}} \leftarrow$ \texttt{estimate\_snr}$(X)$
\IF{$\text{SNR}_{\text{est}} > \tau$}
    \STATE \textit{// Môi trường SNR cao - sử dụng chiến lược tích cực}
    \RETURN \texttt{shape\_adaptive\_v2}$(X, \text{sensitivity}=s)$
\ELSE
    \STATE \textit{// Môi trường SNR thấp - sử dụng chiến lược bảo thủ}
    \RETURN \texttt{shape}$(X)$ \textit{// ShapeDD gốc}
\ENDIF
\end{algorithmic}
\end{algorithm}

\subsubsection{Ưu điểm của phương pháp SNR-Adaptive}

Phương pháp hybrid này mang lại các lợi ích sau:

\begin{enumerate}
    \item \textbf{Robust trên nhiều môi trường:} Tự động thích ứng với đặc điểm SNR của dữ liệu
    \item \textbf{Tối ưu F1-score:} Kết hợp điểm mạnh của cả hai chiến lược
    \item \textbf{Không cần điều chỉnh thủ công:} Tự động ước lượng và lựa chọn chiến lược
    \item \textbf{Nền tảng lý thuyết vững chắc:} Dựa trên lý thuyết phát hiện tín hiệu
\end{enumerate}

\subsubsection{Tối ưu hóa tham số dựa trên đánh giá thực nghiệm}

Qua quá trình đánh giá ban đầu, chúng tôi quan sát thấy rằng việc lựa chọn tham số (ngưỡng SNR $\tau$ và độ nhạy $s$) có ảnh hưởng đáng kể đến hiệu suất phát hiện. Phân tích lý thuyết và thực nghiệm cho thấy:

\textbf{Hiệu ứng pha loãng SNR trong môi trường buffer:}

Khi sử dụng buffer trượt (sliding buffer) với kích thước lớn (750 mẫu) để phát hiện drift, SNR quan sát được thấp hơn đáng kể so với SNR lý thuyết:

\begin{itemize}
    \item SNR lý thuyết (drift độc lập): 0.4 - 4.0
    \item SNR quan sát trong buffer: 0.005 - 0.020
    \item Nguyên nhân: Buffer chứa dữ liệu hỗn hợp [Ổn định: 90\%] [Drift: 10\%] [Ổn định: ...]
\end{itemize}

\textbf{Cơ sở lý thuyết cho việc tối ưu tham số:}

Theo tiêu chuẩn Neyman-Pearson trong lý thuyết phát hiện tín hiệu, ngưỡng tối ưu là ngưỡng cân bằng giữa tỷ lệ false positive (Type I error) và false negative (Type II error) khi chi phí của chúng tương đương. Điều này tương ứng với việc sử dụng cân bằng khoảng 50\% chiến lược tích cực và 50\% chiến lược bảo thủ, đạt được điểm cân bằng tối ưu giữa precision và recall.

\textbf{Cấu hình tham số tối ưu:}

Dựa trên lý thuyết và kết quả thực nghiệm, chúng tôi điều chỉnh tham số như sau:

\begin{table}[H]
\centering
\caption{So sánh cấu hình tham số}
\begin{tabular}{lcccc}
\toprule
\textbf{Cấu hình} & \textbf{$\tau$} & \textbf{$s$} & \textbf{Chiến lược tích cực} & \textbf{F1} \\
\midrule
Ban đầu & 0.008 & high & 64.7\% & 0.684 \\
Tối ưu & 0.010 & medium & 58.7\% & \textbf{0.697} \\
\midrule
\textbf{Cải thiện} & +25\% & - & $\rightarrow$ 50\% & \textbf{+1.9\%} \\
\bottomrule
\end{tabular}
\end{table}

Lý do lựa chọn:
\begin{itemize}
    \item \textbf{Ngưỡng $\tau = 0.010$:} Đạt cân bằng 50/50 theo tiêu chuẩn Neyman-Pearson, phù hợp với SNR quan sát trong buffer (0.005-0.020)
    \item \textbf{Độ nhạy $s = \text{medium}$:} Giảm false positive trong môi trường SNR bị pha loãng bởi buffer, đồng thời duy trì recall tốt
\end{itemize}

\textbf{Kết quả thực nghiệm} (Chi tiết trong Chương \ref{chap:experiments}):

\begin{table}[H]
\centering
\caption{So sánh hiệu suất các phương pháp ShapeDD (F1-score)}
\begin{tabular}{lcccc}
\toprule
\textbf{Phương pháp} & \textbf{F1} & \textbf{Recall} & \textbf{Xếp hạng} & \textbf{Đặc điểm} \\
\midrule
ShapeDD (gốc) & 0.758 & 85.0\% & 1/18 & Bảo thủ 100\% \\
ShapeDD\_Adaptive\_None & 0.740 & 75.0\% & 2/18 & Không lọc FDR \\
ShapeDD\_Adaptive\_v2\_None & 0.736 & 75.0\% & 3/18 & v2, không lọc \\
\textbf{ShapeDD\_SNR\_Adaptive} & \textbf{0.697} & \textbf{66.2\%} & \textbf{4/18} & \textbf{Hybrid thích ứng} \\
DAWIDD & 0.673 & 93.8\% & 5/18 & Baseline \\
MMD & 0.659 & 91.3\% & 6/18 & Baseline \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Phân tích kết quả:}

Phương pháp SNR-Adaptive với cấu hình tối ưu đạt F1 = 0.697, xếp thứ 4 trong tổng số 18 phương pháp được đánh giá. Mặc dù không vượt qua phương pháp ShapeDD gốc (0.758), phương pháp này đạt được:

\begin{itemize}
    \item \textbf{Tính thích ứng cân bằng:} Sử dụng 58.7\% chiến lược tích cực và 41.3\% chiến lược bảo thủ, không thiên vị về một chiến lược duy nhất
    \item \textbf{Hiệu suất cạnh tranh:} Xếp hạng trong top 22\% và vượt qua các phương pháp baseline như DAWIDD, MMD
    \item \textbf{Nền tảng lý thuyết vững chắc:} Tham số được tối ưu dựa trên tiêu chuẩn Neyman-Pearson và Signal Detection Theory
    \item \textbf{Khả năng tối ưu hóa:} Cải thiện 1.9\% F1-score so với cấu hình ban đầu qua quá trình điều chỉnh tham số
\end{itemize}

Kết quả này chứng minh tính khả thi của việc sử dụng SNR để tự động lựa chọn chiến lược phát hiện, đồng thời mở ra hướng nghiên cứu tối ưu hóa thêm cho các môi trường buffer-based detection.

\section{Phương pháp CDT\_MSW – Nhận diện loại trôi dạt dựa trên cửa sổ trượt đa mức}
\label{sec:cdt-msw}

\subsection{Tổng quan}
Phương pháp \textit{Concept Drift Type Identification based on Multi–Sliding Windows (CDT\_MSW)} được đề xuất bởi Guo và cộng sự~\cite{guo2022cdtmsw} nhằm mở rộng chức năng của các bộ phát hiện trôi dạt thông thường. 
Trong khi các thuật toán như DDM, ADWIN hay ShapeDD chỉ xác định \emph{thời điểm xảy ra trôi dạt}, thì CDT\_MSW đi xa hơn bằng cách \textbf{nhận dạng loại trôi dạt} dựa trên hình thái thay đổi của phân phối dữ liệu theo thời gian. 
Phương pháp này đặc biệt hữu ích cho các hệ thống học thích ứng (adaptive learning systems), nơi mà mỗi loại trôi dạt đòi hỏi một chiến lược cập nhật mô hình khác nhau.

\subsection{Nguyên lý hoạt động}
Phương pháp CDT\_MSW sử dụng cấu trúc \textbf{cửa sổ trượt đa mức (multi–sliding windows)} để theo dõi sự thay đổi của phân phối dữ liệu trước và sau điểm trôi dạt. 
Ý tưởng chính là quan sát sự tiến hóa của khoảng cách phân phối khi cửa sổ so sánh mở rộng dần theo thời gian. 
Quá trình nhận diện loại trôi dạt bao gồm ba giai đoạn chính (Hình~\ref{fig:cdt-msw}).

\begin{enumerate}
    \item \textbf{Phát hiện ban đầu (Detection):} 
    Bộ phát hiện trôi dạt (ví dụ ShapeDD) phát hiện một điểm thay đổi tại thời điểm $t_0$. 
    Một cửa sổ tham chiếu $\mathcal{W}_{ref}$ được lấy từ dữ liệu trước thời điểm $t_0$ để biểu diễn khái niệm cũ.
    
    \item \textbf{Giai đoạn mở rộng (Growth process):} 
    Một cửa sổ quan sát $\mathcal{W}_{post}$ bắt đầu từ $t_0$ được mở rộng dần về phía sau dòng dữ liệu. 
    Ở mỗi bước, khoảng cách giữa hai phân phối $P_{ref}$ và $P_{post}$ được tính theo một độ đo thống kê như:
    \begin{equation}
        d_t = D\left(P(X \in \mathcal{W}_{ref}), P(X \in \mathcal{W}_{post}(t))\right),
    \end{equation}
    với $D(\cdot,\cdot)$ là độ đo khoảng cách phân phối, chẳng hạn như Kolmogorov–Smirnov (KS) hoặc Maximum Mean Discrepancy (MMD).
    Khi sai biệt giữa hai bước liên tiếp $\Delta d_t = |d_t - d_{t-1}|$ giảm xuống dưới ngưỡng ổn định $\delta$ trong $p$ bước liên tục, quá trình mở rộng dừng lại. 
    Độ dài vùng chuyển tiếp $L_d = t_{stable} - t_0$ được xem là \emph{độ dài trôi dạt (drift length)}.

    \item \textbf{Theo dõi (Tracking process):}
    Sau khi xác định được $L_d$, thuật toán tiếp tục trượt cửa sổ $\mathcal{W}_{post}$ để theo dõi mức độ khác biệt $r(t)$ giữa phân phối hiện tại và phân phối trước trôi dạt:
    \begin{equation}
        r(t) = D\left(P(X \in \mathcal{W}_{ref}), P(X \in \mathcal{W}_{post}(t))\right),
    \end{equation}
    giúp xác định xem khái niệm mới có ổn định, dao động, hay quay lại trạng thái cũ.
\end{enumerate}

% TODO: Tạo sơ đồ CDT_MSW framework (3 giai đoạn: Detection – Growth – Tracking)
% Có thể sử dụng TikZ hoặc draw.io để vẽ workflow diagram
% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.9\linewidth]{figures/cdt_msw_framework.pdf}
%     \caption{Sơ đồ nguyên lý của phương pháp CDT\_MSW với ba giai đoạn: Detection – Growth – Tracking.}
%     \label{fig:cdt-msw}
% \end{figure}

\subsection{Quy tắc phân loại loại trôi dạt}
Dựa trên độ dài trôi dạt $L_d$ và hình dạng của đường cong $r(t)$, CDT\_MSW phân loại các loại trôi dạt theo các quy tắc sau:

\begin{itemize}
    \item \textbf{Trôi dạt đột ngột (Sudden drift):} 
    $L_d < \theta_{sudden}$, giá trị $r(t)$ tăng nhanh và đạt trạng thái ổn định trong thời gian ngắn.
    \item \textbf{Trôi dạt dần dần (Gradual drift):} 
    $L_d > \theta_{sudden}$, $r(t)$ dao động quanh ngưỡng ổn định và thể hiện sự xen kẽ giữa hai khái niệm.
    \item \textbf{Trôi dạt tăng dần (Incremental drift):} 
    Dạng đặc biệt của gradual drift, trong đó $r(t)$ thay đổi đơn điệu (ít dao động ngược chiều).
    \item \textbf{Trôi dạt lặp lại (Recurring drift):} 
    Sau khi khái niệm mới ổn định, $r(t)$ giảm xuống dưới ngưỡng tương đồng $\epsilon_{recur}$ và duy trì trong thời gian đủ dài $T_{recur}$, biểu thị sự quay lại của khái niệm cũ.
    \item \textbf{Trôi dạt tạm thời (Blip drift):} 
    Sự thay đổi ngắn hạn với $L_d < \theta_{blip}$, khái niệm nhanh chóng quay lại trạng thái ban đầu.
\end{itemize}

\subsection{Các tham số của CDT\_MSW}
Phương pháp CDT\_MSW không yêu cầu đặt ngưỡng cố định cho tất cả các luồng dữ liệu; 
các tham số được điều chỉnh linh hoạt dựa trên tốc độ thay đổi của luồng và độ nhiễu của dữ liệu. 
Bảng~\ref{tab:cdt-msw-params} liệt kê các tham số thường dùng và gợi ý giá trị khởi tạo được đề xuất trong~\cite{guo2022cdtmsw}.

\begin{table}[H]
\centering
\caption{Các tham số chính trong phương pháp CDT\_MSW.}
\label{tab:cdt-msw-params}
\begin{tabular}{lll}
\toprule
\textbf{Ký hiệu} & \textbf{Ý nghĩa} & \textbf{Giá trị gợi ý} \\
\midrule
$w_{ref}$ & Cửa sổ tham chiếu trước drift & 200 mẫu \\
$w_{basic}$ & Cửa sổ so sánh cơ bản & 50 mẫu \\
$\delta$ & Ngưỡng ổn định biến thiên & 0.02 \\
$\theta_{sudden}$ & Ngưỡng phân biệt sudden/progressive & 60 mẫu \\
$\epsilon_{recur}$ & Ngưỡng tương đồng khi khái niệm quay lại & 0.15 \\
$T_{recur}$ & Độ dài tối thiểu để xem là recurrent & 120 mẫu \\
$T_{blip}$ & Độ dài tối đa cho blip drift & 60 mẫu \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Ưu điểm của CDT\_MSW}
So với các phương pháp truyền thống, CDT\_MSW có một số ưu điểm nổi bật:
\begin{itemize}
    \item Không phụ thuộc vào mô hình học máy; hoạt động thuần túy trên phân phối dữ liệu nên áp dụng được cho cả dữ liệu giám sát và phi giám sát.
    \item Có khả năng nhận diện \emph{nhiều loại trôi dạt khác nhau}, bao gồm đột ngột, dần dần, tăng dần, lặp lại và tạm thời.
    \item Cung cấp thông tin định lượng như độ dài trôi dạt và độ ổn định, giúp lựa chọn chiến lược cập nhật mô hình thích hợp.
\end{itemize}

\section{Mô hình học máy và quy trình thích ứng}
\label{sec:model-adaptation}

\subsection{Kiến trúc mô hình}

Hệ thống sử dụng mô hình học máy với ba giai đoạn hoạt động chính:

\textbf{1. Giai đoạn huấn luyện ban đầu (Training Phase):}
\begin{itemize}
    \item Sử dụng scikit-learn để xây dựng pipeline mô hình batch
    \item Cấu trúc: StandardScaler + LogisticRegression
    \item Huấn luyện trên dữ liệu ban đầu (pre-drift data)
    \item Model được lưu dưới dạng pickle file
\end{itemize}

\textbf{2. Giai đoạn triển khai (Deployment Phase):}
\begin{itemize}
    \item Mô hình hoạt động ở chế độ \textit{frozen} (đóng băng)
    \item Không có online learning trong quá trình inference
    \item Chỉ thực hiện prediction trên dữ liệu mới
    \item Theo dõi accuracy để phát hiện suy giảm hiệu suất
\end{itemize}

\textbf{3. Giai đoạn cập nhật (Update Phase):}
\begin{itemize}
    \item Được kích hoạt khi phát hiện drift
    \item Chiến lược cập nhật được chọn dựa trên loại drift
    \item Mô hình mới được huấn luyện hoặc cập nhật
    \item Model được lưu lại và thay thế model cũ
\end{itemize}

\subsection{Chiến lược thích ứng theo loại drift}

Sau khi nhận diện được loại trôi dạt, hệ thống tự động \textbf{chọn chiến lược cập nhật mô hình} phù hợp. 
Mục tiêu của giai đoạn này là đảm bảo mô hình học máy duy trì hiệu suất cao nhất với chi phí cập nhật tối ưu, tránh huấn luyện lại toàn bộ khi không cần thiết. 

Hệ thống triển khai năm chiến lược thích ứng chính dựa trên module \texttt{adaptation\_strategies.py}, được mô tả trong Bảng~\ref{tab:drift-adaptation}.

\begin{table}[H]
\centering
\caption{Chiến lược thích ứng mô hình theo loại trôi dạt trong hệ thống.}
\label{tab:drift-adaptation}
\begin{tabular}{p{3cm}p{5cm}p{6cm}}
\toprule
\textbf{Loại drift} & \textbf{Đặc trưng} & \textbf{Chiến lược triển khai} \\
\midrule
\textbf{Sudden} & 
Thay đổi tức thời, khái niệm cũ không còn hiệu lực &
\textbf{Full model reset:} Tạo mô hình mới hoàn toàn (sklearn pipeline mới), huấn luyện trên dữ liệu post-drift. Hàm: \texttt{adapt\_sudden\_drift()}. \\
\midrule
\textbf{Incremental} & 
Thay đổi đơn điệu, tiến triển liên tục &
\textbf{Gradual online update:} Cập nhật tuần tự từng mẫu bằng River online learning (\texttt{learn\_one}). Hàm: \texttt{adapt\_incremental\_drift()}. \\
\midrule
\textbf{Gradual} & 
Hai khái niệm xen kẽ, dao động không đơn điệu &
\textbf{Weighted update:} Ưu tiên mẫu gần đây hơn (weight = vị trí/tổng), chỉ cập nhật 50\% mẫu cuối. Hàm: \texttt{adapt\_gradual\_drift()}. \\
\midrule
\textbf{Recurrent} & 
Khái niệm cũ quay lại (theo mùa, chu kỳ) &
\textbf{Model cache \& reuse:} Tìm kiếm mô hình đã lưu có phân phối tương tự (KS distance < 0.15), fine-tune nếu tìm thấy. Cache: \texttt{models/cache/}. Hàm: \texttt{adapt\_recurrent\_drift()}. \\
\midrule
\textbf{Blip} & 
Thay đổi tạm thời, ngắn hạn &
\textbf{Minimal update:} Cập nhật bảo thủ với tối đa 5 mẫu, hoặc bỏ qua nếu không có nhãn. Hàm: \texttt{adapt\_blip\_drift()}. \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Cơ chế quyết định tự động}

Trong quá trình vận hành hệ thống, việc lựa chọn chiến lược thích ứng được thực hiện tự động thông qua module \texttt{adaptor.py}. 
Quy trình hoạt động như sau:

\textbf{Bước 1: Lắng nghe sự kiện drift}
\begin{itemize}
    \item Adaptor subscribe vào Kafka topic \texttt{drift.results}
    \item Nhận message chứa thông tin: \texttt{idx}, \texttt{p\_value}, \texttt{drift\_type}, \texttt{window\_path}
    \item Kiểm tra tính hợp lệ của snapshot file
\end{itemize}

\textbf{Bước 2: Load dữ liệu drift window}
\begin{itemize}
    \item Đọc snapshot từ thư mục \texttt{./snapshots/}
    \item Snapshot chứa: ma trận đặc trưng $X$, nhãn $y$ (nếu có), tên features
    \item Kích thước window phụ thuộc vào tham số \texttt{w\_ref} và \texttt{CHUNK\_SIZE}
\end{itemize}

\textbf{Bước 3: Lựa chọn chiến lược thích ứng}

Hệ thống ánh xạ loại drift sang hàm xử lý tương ứng:

    \begin{equation}
    \text{strategy} = 
        \begin{cases}
        \texttt{adapt\_sudden\_drift()} & \text{nếu } \texttt{drift\_type} = \text{``sudden''} \\
        \texttt{adapt\_incremental\_drift()} & \text{nếu } \texttt{drift\_type} = \text{``incremental''} \\
        \texttt{adapt\_gradual\_drift()} & \text{nếu } \texttt{drift\_type} = \text{``gradual''} \\
        \texttt{adapt\_recurrent\_drift()} & \text{nếu } \texttt{drift\_type} = \text{``recurrent''} \\
        \texttt{adapt\_blip\_drift()} & \text{nếu } \texttt{drift\_type} = \text{``blip''} \\
        \texttt{adapt\_incremental\_drift()} & \text{nếu } \texttt{drift\_type} = \text{``undetermined''}
        \end{cases}
    \end{equation}

\textbf{Bước 4: Cập nhật và lưu mô hình}
\begin{itemize}
    \item Thực thi chiến lược đã chọn
    \item Lưu model mới vào \texttt{./models/current\_model.pkl}
    \item Cập nhật version (dựa trên file modification time)
    \item Publish event \texttt{model\_updated} lên topic \texttt{model.updated}
\end{itemize}

\subsection{Ví dụ quy trình thích ứng}

Giả sử tại thời điểm $t = 1504$, ShapeDD phát hiện drift với loại ``sudden'':

\begin{enumerate}
    \item Consumer phát hiện drift, phân loại là ``sudden'', gửi event:
    \begin{verbatim}
    {
      "event": "drift_detected",
      "idx": 1504,
      "p_value": 0.0001,
      "drift_type": "sudden",
      "window_path": "./snapshots/drift_window_1504_xxx.npz"
    }
    \end{verbatim}
    
    \item Adaptor nhận event, load snapshot chứa 251 mẫu (200 pre-drift + 51 post-drift)
    
    \item Gọi \texttt{adapt\_sudden\_drift()}: Tạo model mới, huấn luyện trên dữ liệu post-drift
    
    \item Lưu model mới, publish \texttt{model\_updated} event
\end{enumerate}

\subsection{Ưu điểm của cơ chế tự động}

Cơ chế quyết định tự động mang lại các lợi ích:

\begin{itemize}
    \item \textbf{Tự động hóa hoàn toàn:} Không cần can thiệp thủ công
    \item \textbf{Tối ưu hóa chi phí:} Chọn chiến lược phù hợp tránh lãng phí tài nguyên
    \item \textbf{Phản hồi nhanh:} Thời gian từ phát hiện đến cập nhật < 1 giây
    \item \textbf{Có khả năng mở rộng:} Dễ dàng thêm chiến lược mới
\end{itemize}
