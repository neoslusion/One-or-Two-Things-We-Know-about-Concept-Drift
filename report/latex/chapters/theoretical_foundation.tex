\chapter{Cơ sở lý thuyết}

\section{Khái niệm và các loại concept drift}

\subsection{Định nghĩa concept drift}

Concept drift, hay còn gọi là sự trôi dạt khái niệm, đề cập đến những thay đổi trong phân phối dữ liệu được tạo ra theo thời gian, đặc biệt là trong môi trường động và thay đổi theo thời gian, chẳng hạn như trong ứng dụng về IoT~\cite{ramakrishnan2014enabling}. Cụ thể hơn, sự trôi dạt khái niệm là một vấn đề trong đó các mối quan hệ thống kê giữa các giá trị đầu vào và giá trị mục tiêu bị thay đổi theo thời gian theo cách không thể dự đoán được~\cite{schlimmer1986incremental}.

Sự trôi dạt khái niệm có thể dẫn đến hiệu suất giảm trong quá trình vận hành thực tế của mô hình học máy, điều này trái ngược với hiệu suất được đánh giá trên tập dữ liệu thử nghiệm tĩnh trong quá trình phát triển.

\subsection{Phân loại các loại concept drift}

Có nhiều loại trôi dạt khác nhau, tùy thuộc vào các yếu tố dữ liệu đang thay đổi. Các loại chính của sự trôi dạt khái niệm bao gồm~\cite{sciencedirect2024drift, hovakimyan2024evolving}:

\textbf{Sự trôi dạt ảo (Virtual Drift):} Còn được gọi là sự dịch chuyển biến phụ (covariate shift), đề cập đến tình huống mà sự thay đổi xảy ra trong phân phối các trường hợp đầu vào $P(X)$, trong khi xác suất hậu nghiệm của các giá trị mục tiêu $P(Y|X)$ vẫn không đổi~\cite{moreno2012unifying}.

\textbf{Sự trôi dạt thực (Real Drift):} Sự thay đổi trong xác suất hậu nghiệm của các giá trị mục tiêu (tức là các lớp) $P(Y|X)$ được gọi là sự trôi dạt thực. Sự trôi dạt thực có thể không ảnh hưởng đến sự phân phối các trường hợp đầu vào $P(X)$. Ví dụ, người ta có thể đề cập đến sự thay đổi trong sở thích của người dùng khi họ theo dõi các kênh tin tức phát trực tuyến, trong khi sự phân phối các mục tin tức nhận được thường không thay đổi~\cite{gama2014survey}.

\textbf{Sự trôi dạt đột ngột (Abrupt Drift):} Biểu thị trường hợp khi sự phân phối dữ liệu thay đổi đột ngột tại một thời điểm cụ thể. Drift đột ngột dễ nhận biết nhưng đòi hỏi cơ chế phát hiện và thích ứng nhanh để tránh suy giảm hiệu suất nghiêm trọng~\cite{basseville1993detection}.

\textbf{Sự trôi dạt dần dần (Gradual Drift):} Sự trôi dạt dần dần biểu thị trường hợp khi sự phân phối dữ liệu thay đổi dần dần theo thời gian qua một khoảng thời gian chuyển tiếp. Trong giai đoạn chuyển tiếp này, dữ liệu có thể đến từ cả phân phối cũ và phân phối mới với tỷ lệ thay đổi dần~\cite{gama2014survey}.

\textbf{Sự trôi dạt tăng dần (Incremental Drift):} Thể hiện sự tiến hóa dần dần của phân phối dữ liệu theo từng bước nhỏ liên tục. Ví dụ như sự tiến hóa dần dần của hệ thống đề xuất người dùng ngày càng tiến hóa và nhiều hơn dựa trên sự thay đổi sở thích của người dùng theo thời gian~\cite{hovakimyan2024evolving}.

\textbf{Sự trôi dạt lặp lại (Recurrent Drift):} Trôi dạt lặp lại là khi dữ liệu quay trở lại trạng thái cũ sau một thời gian, hoặc lặp lại theo chu kỳ. Những thay đổi trong dữ liệu không phải mới mà đã từng xảy ra trước đó. Ví dụ như xu hướng thời trang thay đổi theo mùa, tuần hoàn theo từng năm~\cite{hovakimyan2024evolving}.

\subsection{Ảnh hưởng của concept drift}

Sự trôi dạt khái niệm có thể ảnh hưởng lớn đến hiệu suất của mô hình dự đoán, đặc biệt là khi mô hình học từ luồng dữ liệu. Một loạt các dịch vụ/ứng dụng trong bối cảnh hệ thống và mạng truyền thông có thể bị cản trở bởi sự trôi dạt khái niệm như~\cite{ramakrishnan2014enabling}:

\begin{itemize}
    \item \textbf{Hệ thống phát hiện xâm nhập (IDS):} Các mẫu tấn công mạng liên tục thay đổi, đòi hỏi IDS phải thích ứng với các mối đe dọa mới
    \item \textbf{Hệ thống phân loại và dự đoán lưu lượng:} Mẫu lưu lượng mạng thay đổi theo thời gian, ảnh hưởng đến độ chính xác dự đoán
    \item \textbf{Industrial IoT (IIoT):} Đặc biệt trong các kỹ thuật bảo trì dựa trên tình trạng (Condition-Based Maintenance - CBM) được sử dụng để dự đoán các điều kiện bất thường và thời gian bảo trì thông qua phân tích dữ liệu IIoT~\cite{jourdan2021machine}
    \item \textbf{Thành phố thông minh:} Dữ liệu được thu thập cho nhiều mục đích như đảm bảo an ninh mạng, dự đoán ô nhiễm không khí, dự đoán giao thông đường bộ và dự báo tải điện
\end{itemize}

Sự phân phối các mẫu lỗi có thể thay đổi theo thời gian do máy móc lão hóa và quy trình bảo trì. Do đó, một kỹ thuật CBM không có khả năng xử lý sự trôi dạt khái niệm sẽ hoạt động kém~\cite{jourdan2021machine}. Thật vậy, sự trôi dạt khái niệm có thể ảnh hưởng đến hiệu quả và tính mạnh mẽ của phân tích luồng dữ liệu~\cite{tripathi2021ensuring}.

Trong môi trường không cố định, có một số cân nhắc mà các mô hình dự đoán phải tính đến để phát hiện và tự thích ứng với sự trôi dạt khái niệm, nếu không, hiệu suất của các mô hình này sẽ giảm sút về độ chính xác và độ mạnh mẽ. Theo thời gian, một mô hình dự đoán có thể cần cập nhật các tham số và cấu trúc của nó bằng cách kết hợp các dữ liệu huấn luyện mới hoặc thay thế hoàn toàn mô hình cũ để xử lý sự trôi dạt khái niệm.

\section{Cách tiếp cận nghiên cứu}

Chương này trình bày khung phương pháp luận để điều tra phát hiện concept drift sử dụng phương pháp Shape Drift Detector (ShapeDD). Cách tiếp cận của chúng tôi tập trung vào việc hiểu các nền tảng lý thuyết của ShapeDD, triển khai thuật toán cho các kịch bản drift khác nhau, và thực hiện đánh giá thực nghiệm toàn diện để đánh giá hiệu quả của nó trên các loại concept drift khác nhau.

Phương pháp luận nghiên cứu bao gồm ba thành phần chính: (1) phân tích lý thuyết của thuật toán ShapeDD và các nền tảng Maximum Mean Discrepancy (MMD) cơ bản, (2) triển khai và tối ưu hóa hệ thống phát hiện cho các bộ dữ liệu tổng hợp và thực tế, và (3) đánh giá thực nghiệm toàn diện trên các mẫu drift và cấu hình tham số khác nhau.

\section{Nền tảng lý thuyết của Shape Drift Detector}

\subsection{Maximum Mean Discrepancy (MMD)}

Shape Drift Detector (ShapeDD) dựa trên Maximum Mean Discrepancy (MMD), một thước đo thống kê được sử dụng để so sánh hai phân phối xác suất $P$ và $Q$. Ý tưởng cốt lõi là ánh xạ dữ liệu từ không gian gốc vào không gian feature cao chiều nơi việc so sánh trở nên nhạy cảm hơn với sự khác biệt phân phối.

\subsubsection{Định nghĩa và intuition}

MMD đo lường khoảng cách giữa hai phân phối bằng cách tìm hàm $f$ có thể phân biệt tốt nhất giữa chúng. Nếu hai phân phối giống nhau, giá trị kỳ vọng của bất kỳ hàm nào áp dụng lên chúng sẽ giống nhau. Ngược lại, nếu khác nhau, sẽ tồn tại một hàm cho phép phân biệt rõ ràng.

MMD được định nghĩa chính thức như:
\begin{equation}
\text{MMD}(P, Q) = \sup_{f \in \mathcal{F}} \left| \mathbb{E}_{X \sim P}[f(X)] - \mathbb{E}_{Y \sim Q}[f(Y)] \right|
\end{equation}

trong đó:
\begin{itemize}
    \item $P$ và $Q$ là hai phân phối cần được so sánh
    \item $X \sim P$ đại diện cho biến ngẫu nhiên được lấy mẫu từ phân phối $P$
    \item $Y \sim Q$ đại diện cho biến ngẫu nhiên được lấy mẫu từ phân phối $Q$
    \item $\mathcal{F}$ là một lớp hàm $f$ sao cho $\|f\|_{\mathcal{H}} \leq 1$ trong Reproducing Kernel Hilbert Space (RKHS)
    \item $\sup$ biểu thị supremum (cận trên nhỏ nhất)
\end{itemize}

\textbf{Intuition:} Trong không gian ban đầu, hai phân phối có thể khó phân biệt. Bằng cách ánh xạ vào RKHS thông qua hàm kernel, các cấu trúc phức tạp của phân phối trở nên rõ ràng hơn. MMD đo lường khoảng cách giữa "trung bình" (mean embedding) của hai phân phối trong không gian này.

\subsubsection{Kernel trick và RKHS}

Trong thực tế, việc tìm supremum trên $\mathcal{F}$ là không khả thi về mặt tính toán. Do đó, MMD thường được triển khai trong RKHS sử dụng kernel trick với hàm kernel $k(x, y)$:

\begin{equation}
k(x, y) = \langle \phi(x), \phi(y) \rangle_{\mathcal{H}}
\end{equation}

trong đó $\phi(x)$ ánh xạ điểm $x$ vào RKHS $\mathcal{H}$ và $\langle \cdot, \cdot \rangle_{\mathcal{H}}$ là tích vô hướng trong $\mathcal{H}$.

\textbf{Lựa chọn kernel phổ biến:} Gaussian RBF kernel được sử dụng rộng rãi nhất do tính chất universal (có thể xấp xỉ bất kỳ hàm liên tục nào):

\begin{equation}
k(x, y) = \exp\left(-\frac{\|x - y\|^2}{2\sigma^2}\right)
\end{equation}

Tham số $\sigma$ (bandwidth) điều khiển độ nhạy: giá trị nhỏ tập trung vào sự khác biệt cục bộ, giá trị lớn nắm bắt cấu trúc toàn cục.

\subsubsection{Công thức tính toán}

MMD bình phương trong RKHS trở thành:
\begin{equation}
\text{MMD}^2(P, Q) = \mathbb{E}_{X, X' \sim P}[k(X, X')] + \mathbb{E}_{Y, Y' \sim Q}[k(Y, Y')] - 2\mathbb{E}_{X \sim P, Y \sim Q}[k(X, Y)]
\end{equation}

\textbf{Giải thích ba thành phần:}
\begin{itemize}
    \item \textbf{Thành phần 1:} $\mathbb{E}_{X, X' \sim P}[k(X, X')]$ - độ tương đồng trung bình giữa các điểm trong phân phối $P$
    \item \textbf{Thành phần 2:} $\mathbb{E}_{Y, Y' \sim Q}[k(Y, Y')]$ - độ tương đồng trung bình giữa các điểm trong phân phối $Q$
    \item \textbf{Thành phần 3:} $-2\mathbb{E}_{X \sim P, Y \sim Q}[k(X, Y)]$ - độ tương đồng chéo giữa hai phân phối (có dấu âm)
\end{itemize}

Nếu $P = Q$, ba thành phần này cân bằng nhau và $\text{MMD}^2 = 0$. Nếu $P \neq Q$, sự khác biệt trong cấu trúc nội bộ và tương tác chéo dẫn đến $\text{MMD}^2 > 0$.

\subsubsection{Ước lượng thực nghiệm}

Để ước tính thực nghiệm với mẫu $\{x_i\}_{i=1}^n$ từ $P$ và $\{y_j\}_{j=1}^m$ từ $Q$:

\begin{equation}
\widehat{\text{MMD}}^2 = \frac{1}{n(n-1)} \sum_{i \neq j} k(x_i, x_j) + \frac{1}{m(m-1)} \sum_{i \neq j} k(y_i, y_j) - \frac{2}{nm} \sum_{i,j} k(x_i, y_j)
\end{equation}

\textbf{Tính chất thống kê:} $\widehat{\text{MMD}}^2$ là unbiased estimator của $\text{MMD}^2$ với phương sai giảm theo tốc độ $O(1/n + 1/m)$ khi kích thước mẫu tăng.

\textbf{Ví dụ minh họa:} Xét hai phân phối 1D:
\begin{itemize}
    \item $P = \mathcal{N}(0, 1)$ - phân phối chuẩn tâm 0, phương sai 1
    \item $Q = \mathcal{N}(2, 1)$ - phân phối chuẩn tâm 2, phương sai 1
\end{itemize}

Với Gaussian kernel ($\sigma = 1$), MMD sẽ nắm bắt được sự dịch chuyển trung bình (mean shift) giữa hai phân phối. Khi $n, m \to \infty$, $\widehat{\text{MMD}}^2$ hội tụ về giá trị dương phản ánh khoảng cách thực giữa $P$ và $Q$.

\subsection{Các phương pháp phát hiện drift cơ bản}

Các phương pháp phát hiện drift cơ bản đã được trình bày chi tiết trong Chương 2. Để cung cấp ngữ cảnh cho ShapeDD, chúng ta tóm tắt ngắn gọn các đặc điểm chính:

\textbf{Phương pháp dựa trên hiệu suất mô hình:} DDM, EDDM, MDDM, FHDDMS theo dõi các thống kê lỗi của mô hình và phát hiện drift khi hiệu suất giảm đáng kể. Các phương pháp này phụ thuộc vào nhãn ground truth và có thể bị trễ trong việc phát hiện do cần thu thập đủ lỗi.

\textbf{Phương pháp dựa trên cửa sổ thích ứng:} ADWIN điều chỉnh động kích thước cửa sổ dựa trên sự thay đổi được quan sát, đạt được cân bằng giữa độ nhạy và ổn định với đảm bảo lý thuyết $O(\log W)$ về bộ nhớ.

\textbf{Phương pháp dựa trên độc lập thống kê:} DAWIDD phát hiện drift thông qua việc đo lường sự phụ thuộc giữa features và thời gian, cho phép phát hiện sớm mà không cần nhãn.

So với các phương pháp này, ShapeDD mang lại góc nhìn khác biệt bằng cách sử dụng Maximum Mean Discrepancy (MMD) để so sánh trực tiếp phân phối dữ liệu trong không gian kernel, kết hợp với kỹ thuật phát hiện hình dạng (shape detection) để giảm nhiễu và tăng độ chính xác định vị drift.

\subsection{Thuật toán Shape Drift Detector}

Shape Drift Detector (ShapeDD)~\cite{hinder2024survey_partA} là một detector drift dựa trên meta-statistic hoạt động thông qua quá trình đa giai đoạn để xác định concept drift trong luồng dữ liệu. Thuật toán sử dụng MMD như thước đo thống kê cốt lõi và theo một cách tiếp cận có hệ thống bao gồm bốn giai đoạn chính. Điểm mạnh của ShapeDD nằm ở khả năng lọc nhiễu thông qua việc phát hiện "hình dạng" (shape) đặc trưng của drift trong chuỗi thống kê MMD.

\subsubsection{Giai đoạn 1: Thu thập dữ liệu (Data Collection)}

Giai đoạn đầu tiên bao gồm thu thập dữ liệu sử dụng kỹ thuật cửa sổ trượt. ShapeDD sử dụng chiến lược cửa sổ đôi (double window) với kích thước $2l_1$ để so sánh hai đoạn dữ liệu liên tiếp:

\begin{itemize}
    \item \textbf{Cửa sổ tham chiếu}: $l_1$ điểm dữ liệu đầu tiên $[t-2l_1+1, t-l_1]$
    \item \textbf{Cửa sổ hiện tại}: $l_1$ điểm dữ liệu tiếp theo $[t-l_1+1, t]$
\end{itemize}

Đối với luồng dữ liệu $\mathcal{S} = \{x_1, x_2, \ldots, x_n\}$, chúng ta duy trì cửa sổ trượt $W_t$ có kích thước tổng cộng $2l_1$ tại thời điểm $t$:
\begin{equation}
W_t = \{x_{t-2l_1+1}, x_{t-2l_1+2}, \ldots, x_t\}
\end{equation}

\textbf{Lựa chọn kích thước cửa sổ $l_1$:} Đây là tham số quan trọng nhất của ShapeDD:
\begin{itemize}
    \item $l_1$ nhỏ (50-100): Nhạy với drift nhanh nhưng dễ bị nhiễu
    \item $l_1$ trung bình (200-500): Cân bằng giữa độ nhạy và ổn định
    \item $l_1$ lớn (>500): Ổn định nhưng trễ phát hiện cao
    \item \textbf{Adaptive sizing}: $l_1 = \alpha \times \text{stream\_length}$ với $\alpha \in [0.03, 0.10]$ điều chỉnh tự động theo độ dài luồng
\end{itemize}

\subsubsection{Giai đoạn 2: Xây dựng feature (Feature Construction)}

Trong giai đoạn này, chúng ta xây dựng ma trận tương đồng (similarity matrix) sử dụng hàm kernel để nắm bắt mối quan hệ giữa các điểm dữ liệu. Gaussian RBF kernel thường được sử dụng:

\begin{equation}
k(x_i, x_j) = \exp\left(-\frac{\|x_i - x_j\|^2}{2\sigma^2}\right)
\end{equation}

Điều này tạo ra ma trận kernel đối xứng $K \in \mathbb{R}^{2l_1 \times 2l_1}$ trong đó $K_{ij} = k(x_i, x_j)$ biểu thị sự tương đồng giữa các điểm dữ liệu $x_i$ và $x_j$.

\textbf{Lựa chọn bandwidth $\sigma$:} Có thể sử dụng median heuristic để tự động chọn $\sigma$:
\begin{equation}
\sigma = \text{median}\left(\{\|x_i - x_j\| : i, j \in W_t, i \neq j\}\right)
\end{equation}

Phương pháp này đảm bảo kernel thích nghi với scale của dữ liệu.

\textbf{Hiệu quả tính toán:} Ma trận kernel có thể được cập nhật tăng dần khi cửa sổ trượt:
\begin{itemize}
    \item Tính toán đầy đủ: $O(l_1^2)$ cho mỗi cửa sổ
    \item Cập nhật tăng dần: Chỉ cần tính $O(l_1)$ phần tử mới khi thêm điểm dữ liệu
\end{itemize}

\subsubsection{Giai đoạn 3: Tính toán sự khác biệt (Difference Computation)}

Cốt lõi của ShapeDD bao gồm tính toán sự khác biệt thống kê giữa hai nửa của cửa sổ trượt sử dụng MMD có trọng số. Chúng ta định nghĩa hàm trọng số $w(t)$ tạo ra trọng số tương phản (+1 và -1) cho hai nửa của cửa sổ:

\begin{equation}
w(t) = \begin{cases}
+\frac{1}{l_1} & \text{nếu } t \in [1, l_1] \quad \text{(cửa sổ tham chiếu)} \\
-\frac{1}{l_1} & \text{nếu } t \in [l_1+1, 2l_1] \quad \text{(cửa sổ hiện tại)}
\end{cases}
\end{equation}

Thống kê MMD có trọng số sau đó được tính như:
\begin{equation}
\text{MMD}^2_t = \sum_{i,j=1}^{2l_1} w_i w_j K_{ij}
\end{equation}

\textbf{Giải thích công thức:} Khai triển ra, ta có:
\begin{align}
\text{MMD}^2_t = &\frac{1}{l_1^2} \sum_{i,j=1}^{l_1} K_{ij} \quad \text{(tương đồng trong cửa sổ tham chiếu)} \nonumber \\
+ &\frac{1}{l_1^2} \sum_{i,j=l_1+1}^{2l_1} K_{ij} \quad \text{(tương đồng trong cửa sổ hiện tại)} \nonumber \\
- &\frac{2}{l_1^2} \sum_{i=1}^{l_1} \sum_{j=l_1+1}^{2l_1} K_{ij} \quad \text{(tương đồng chéo)}
\end{align}

Đây chính là công thức MMD giữa hai phân phối được định nghĩa bởi hai nửa cửa sổ.

Tính toán này được thực hiện trên toàn bộ luồng dữ liệu sử dụng phương pháp cửa sổ trượt, tạo ra chuỗi thời gian các giá trị MMD: $\{\text{MMD}^2_1, \text{MMD}^2_2, \ldots, \text{MMD}^2_T\}$.

\textbf{Ý nghĩa của chuỗi MMD:} Khi drift xảy ra tại thời điểm $t_d$:
\begin{itemize}
    \item Trước drift ($t < t_d - l_1$): Cả hai nửa cửa sổ đều từ phân phối cũ $\Rightarrow$ $\text{MMD}^2_t \approx 0$
    \item Tại drift ($t_d - l_1 \leq t \leq t_d$): Cửa sổ tham chiếu từ phân phối cũ, cửa sổ hiện tại từ phân phối mới $\Rightarrow$ $\text{MMD}^2_t$ tăng mạnh
    \item Sau drift ($t > t_d + l_1$): Cả hai nửa đều từ phân phối mới $\Rightarrow$ $\text{MMD}^2_t \approx 0$
\end{itemize}

Điều này tạo ra hình dạng tam giác (triangular shape) đặc trưng trong chuỗi MMD tại vị trí drift.

\subsubsection{Giai đoạn 4: Xác thực thống kê (Statistical Validation)}

Giai đoạn cuối cùng bao gồm hai bước: phát hiện hình dạng (shape detection) và xác thực thống kê.

\textbf{Bước 4.1: Shape Detection qua Convolution}

Để phát hiện hình dạng tam giác, ShapeDD sử dụng bộ lọc convolution $h'_l$ được thiết kế để nhạy với biên tăng-giảm:

\begin{equation}
h'_l(t) = \begin{cases}
+1 & \text{nếu } t \in [0, l] \\
-1 & \text{nếu } t \in (l, 2l]
\end{cases}
\end{equation}

Tín hiệu shape được tính bằng convolution:
\begin{equation}
\text{shape}_t = (h'_l * \text{MMD}^2)(t) = \sum_{i=0}^{2l} h'_l(i) \cdot \text{MMD}^2_{t-i}
\end{equation}

\textbf{Zero-crossing detection:} Drift candidate được xác định khi tín hiệu shape đổi dấu (từ dương sang âm hoặc ngược lại):
\begin{equation}
\text{Candidate}(t) = \text{sign}(\text{shape}_t) \neq \text{sign}(\text{shape}_{t-1})
\end{equation}

\textbf{Bước 4.2: Permutation Test}

Mỗi drift candidate được xác thực bằng permutation test để loại bỏ false positive:

\begin{enumerate}
    \item Tính $\text{MMD}^2_{\text{obs}}$ từ dữ liệu gốc tại vị trí candidate
    \item Lặp $N_{\text{perm}}$ lần (thường 1000-5000):
    \begin{enumerate}
        \item Hoán vị ngẫu nhiên nhãn của hai nửa cửa sổ
        \item Tính $\text{MMD}^2_{\text{perm}}$ với dữ liệu hoán vị
    \end{enumerate}
    \item Tính p-value:
    \begin{equation}
    p\text{-value} = \frac{\#\{\text{MMD}^2_{\text{perm}} \geq \text{MMD}^2_{\text{obs}}\}}{N_{\text{perm}}}
    \end{equation}
    \item Nếu $p\text{-value} < \alpha$ (thường $\alpha = 0.05$), chấp nhận drift
\end{enumerate}

\textbf{Tại sao permutation test hiệu quả?} Nếu không có drift thực sự, việc hoán vị nhãn không nên thay đổi nhiều $\text{MMD}^2$. Nếu có drift, $\text{MMD}^2_{\text{obs}}$ sẽ lớn hơn đáng kể so với các giá trị permutation.

\textbf{Độ phức tạp tính toán:} Permutation test là bước tốn thời gian nhất: $O(N_{\text{perm}} \cdot l_1^2)$. Tuy nhiên, vì chỉ áp dụng cho các candidate (không phải mọi thời điểm), chi phí trung bình vẫn chấp nhận được.

\section{Thuật toán phát hiện drift cải tiến}

\subsection{Chi tiết triển khai ShapeDD}

Thuật toán ShapeDD hoàn chỉnh có thể được tóm tắt trong các bước sau:

\textbf{Thuật toán: Shape Drift Detector (ShapeDD)}
\begin{enumerate}
    \item \textbf{Khởi tạo tham số:} Đặt kích thước cửa sổ $l_1$, băng thông kernel $\sigma$, ngưỡng ý nghĩa $\alpha$
    \item \textbf{Thu thập dữ liệu:} Duy trì cửa sổ trượt $W_t$ có kích thước $2l_1$
    \item \textbf{Tính toán kernel:} Tính ma trận tương đồng $K$ sử dụng Gaussian RBF kernel
    \item \textbf{Tính toán MMD:} Áp dụng hàm trọng số và tính thống kê MMD trên cửa sổ trượt
    \item \textbf{Phân tích shape:} Áp dụng convolution để xác định điểm thay đổi tiềm năng qua zero-crossing
    \item \textbf{Xác thực thống kê:} Sử dụng permutation test để xác thực các điểm thay đổi được phát hiện với p-value
    \item \textbf{Tín hiệu drift:} Xuất tín hiệu phát hiện drift khi p-value $< \alpha$
\end{enumerate}

\textbf{Độ phức tạp tính toán:}
\begin{itemize}
    \item Tính toán ma trận kernel: $O(n^2)$ trong đó $n$ là kích thước cửa sổ
    \item Tính toán MMD: $O(n^2)$ mỗi vị trí cửa sổ trượt
    \item Permutation testing: $O(k \cdot n^2)$ trong đó $k$ là số lượng permutation
    \item Độ phức tạp tổng thể: $O(T \cdot n^2)$ cho luồng có độ dài $T$
\end{itemize}

\subsection{Khung chiến lược thích ứng}

\subsection{Phương pháp Meta-Learning}

Chúng tôi phát triển khung meta-learning tự động lựa chọn chiến lược thích ứng dựa trên đặc trưng drift được phát hiện:

\textbf{Trích xuất feature:} Đối với mỗi episode drift được phát hiện, chúng tôi trích xuất feature mô tả:
\begin{itemize}
    \item Mức độ drift: $|\Delta(t_1, t_2)|$
    \item Tốc độ drift: $\frac{|\Delta(t_1, t_2)|}{t_2 - t_1}$
    \item Chiều bị ảnh hưởng: Số lượng feature cho thấy thay đổi đáng kể
    \item Ngữ cảnh lịch sử: Các mẫu drift trước đây và kết quả thích ứng
\end{itemize}

\textbf{Lựa chọn chiến lược:} Meta-classifier được huấn luyện trên các episode drift lịch sử dự đoán chiến lược thích ứng phù hợp nhất:

\begin{equation}
s^* = \arg\max_{s \in \mathcal{S}} P(s|\mathbf{f}_{\text{drift}})
\end{equation}

trong đó $\mathbf{f}_{\text{drift}}$ biểu thị các feature drift được trích xuất và $\mathcal{S}$ là tập hợp các chiến lược thích ứng có sẵn.

\subsection{Quản lý cửa sổ thích ứng}

Chúng tôi đề xuất chiến lược quản lý cửa sổ thích ứng điều chỉnh kích thước cửa sổ dựa trên đặc trưng drift:

\begin{equation}
w_{\text{size}}(t) = w_{\text{base}} \cdot \exp(-\lambda \cdot \Delta(t))
\end{equation}

trong đó $w_{\text{base}}$ là kích thước cửa sổ cơ sở, $\lambda$ là tham số suy giảm, và $\Delta(t)$ là mức độ drift được phát hiện.

\section{Thiết kế thực nghiệm}

\subsection{Tạo bộ dữ liệu tổng hợp}

Để đánh giá hiệu quả của ShapeDD trên các kịch bản drift khác nhau, chúng tôi tạo ra các bộ dữ liệu tổng hợp được kiểm soát với đặc trưng drift được định nghĩa chính xác. Cách tiếp cận này cho phép chúng tôi đánh giá hiệu suất thuật toán dưới các điều kiện đã biết và phân tích tác động của các tham số khác nhau.

\textbf{Bộ dữ liệu Abrupt Drift:} Chúng tôi tạo ra các bộ dữ liệu với thay đổi đột ngột, tức thì trong phân phối dữ liệu. Bộ dữ liệu bao gồm 10,000 điểm dữ liệu với sampling đồng nhất trong không gian đơn vị. Drift được giới thiệu bằng cách dịch chuyển các tham số phân phối tại các điểm thời gian được chọn ngẫu nhiên:

\begin{itemize}
    \item Kích thước dataset: 10,000 điểm dữ liệu
    \item Mức độ drift: 0.5 (dịch chuyển độ lệch chuẩn)
    \item Số điểm drift: 10 vị trí được phân phối ngẫu nhiên
    \item Loại phân phối: Phân phối đồng nhất với dịch chuyển tham số đột ngột
\end{itemize}

\textbf{Bộ dữ liệu Incremental Drift:} Chúng tôi tạo ra các bộ dữ liệu thể hiện thay đổi dần dần, liên tục trong các tham số phân phối theo thời gian. Điều này đại diện cho các mẫu drift tiến hóa chậm thường được tìm thấy trong các ứng dụng thực tế:

\begin{itemize}
    \item Kích thước dataset: 10,000 điểm dữ liệu  
    \item Tiến triển drift: Tiến hóa tham số tuyến tính liên tục
    \item Loại phân phối: Gaussian hoặc đồng nhất với tham số thay đổi dần dần
    \item Tốc độ drift: Tỷ lệ thay đổi tham số có thể cấu hình mỗi đơn vị thời gian
\end{itemize}

Quá trình tạo dữ liệu tổng hợp đảm bảo khả năng tái tạo và cho phép đánh giá có hệ thống hiệu suất phát hiện trên các cường độ và mẫu drift khác nhau.

\textbf{Biến thiên tham số:} Đối với mỗi loại drift, chúng tôi tạo ra nhiều biến thể dataset với:
\begin{itemize}
    \item Mức độ drift khác nhau (0.1, 0.3, 0.5, 0.7, 0.9)
    \item Chiều khác nhau (2D, 5D, 10D, 20D)
    \item Mức nhiễu khác nhau (0\%, 5\%, 10\%, 15\%, 20\%)
    \item Tần suất drift khác nhau (xuất hiện drift thưa thớt vs thường xuyên)
\end{itemize}

\subsection{Giao thức đánh giá}

\textbf{Đánh giá Prequential:} Chúng tôi sử dụng cách tiếp cận test-then-train để đánh giá streaming thực tế:

\textbf{Các bước giao thức đánh giá:}
\begin{enumerate}
    \item Khởi tạo mô hình $M$ và các metric hiệu suất
    \item Đối với mỗi điểm dữ liệu $(x_t, y_t)$ trong luồng:
    \begin{enumerate}
        \item Thực hiện dự đoán: $\hat{y}_t \leftarrow M.\text{predict}(x_t)$
        \item Cập nhật metric hiệu suất với $(\hat{y}_t, y_t)$
        \item Cập nhật mô hình: $M.\text{update}(x_t, y_t)$
        \item Áp dụng phát hiện drift và thích ứng nếu cần
    \end{enumerate}
    \item Báo cáo metric hiệu suất tích lũy
\end{enumerate}

\textbf{Metric hiệu suất:} Chúng tôi sử dụng nhiều metric để đánh giá các khía cạnh khác nhau của hiệu suất:

\begin{itemize}
    \item \textit{Độ chính xác phân loại}: Độ chính xác dự đoán tổng thể
    \item \textit{Độ trễ phát hiện}: Thời gian giữa xuất hiện drift và phát hiện
    \item \textit{Tỷ lệ báo động nhầm}: Tần suất tín hiệu drift không chính xác
    \item \textit{Hiệu quả thích ứng}: Phục hồi hiệu suất sau drift
    \item \textit{Chi phí tính toán}: Yêu cầu runtime và bộ nhớ
\end{itemize}

\subsection{Phân tích thống kê}

\textbf{Kiểm định ý nghĩa:} Chúng tôi sử dụng các test thống kê phù hợp để xác minh ý nghĩa của sự khác biệt hiệu suất:

\begin{itemize}
    \item Friedman test để so sánh nhiều thuật toán trên các dataset
    \item Nemenyi post-hoc test để so sánh theo cặp
    \item McNemar test để so sánh độ chính xác phân loại
\end{itemize}

\textbf{Phân tích Effect Size:} Ngoài ý nghĩa thống kê, chúng tôi tính effect size để đánh giá ý nghĩa thực tế:

\begin{equation}
\text{Cohen's d} = \frac{\mu_1 - \mu_2}{\sqrt{\frac{\sigma_1^2 + \sigma_2^2}{2}}}
\end{equation}

\section{Chi tiết triển khai}

\subsection{Framework phần mềm}

Chúng tôi phát triển framework phần mềm toàn diện cho thí nghiệm concept drift:

\textbf{Các thành phần cốt lõi:}
\begin{itemize}
    \item Stream simulation engine để tạo dữ liệu tổng hợp
    \item Thư viện phát hiện drift modular với các thuật toán pluggable
    \item Framework chiến lược thích ứng với nhiều chiến lược được triển khai
    \item Bộ đánh giá toàn diện với nhiều metric
\end{itemize}

\textbf{Technical Stack:}
\begin{itemize}
    \item Python 3.8+ với NumPy, SciPy, và scikit-learn
    \item Apache Kafka để mô phỏng stream processing
    \item PostgreSQL để lưu trữ và phân tích kết quả
    \item Jupyter notebook để trực quan hóa và phân tích
\end{itemize}

\subsection{Hạ tầng tính toán}

\textbf{Yêu cầu phần cứng:}
\begin{itemize}
    \item Bộ xử lý đa lõi để thực thi thí nghiệm song song
    \item RAM đủ để xử lý dataset quy mô lớn
    \item Dung lượng lưu trữ cho kết quả thí nghiệm và dataset
\end{itemize}

\textbf{Quản lý thí nghiệm:}
\begin{itemize}
    \item Version control cho cấu hình thí nghiệm
    \item Lập lịch và thực thi thí nghiệm tự động
    \item Khả năng tái tạo kết quả thông qua quản lý random seed
\end{itemize}

\section{Chiến lược xác thực}

\subsection{Cross-validation cho phát hiện drift}

Cross-validation truyền thống không phù hợp cho dữ liệu thời gian có drift. Chúng tôi sử dụng temporal cross-validation:

\begin{itemize}
    \item \textit{Sliding window validation}: Sử dụng cửa sổ thời gian chồng chéo
    \item \textit{Blocked cross-validation}: Tôn trọng thứ tự thời gian trong fold
    \item \textit{Prequential validation}: Cách tiếp cận test-then-train
\end{itemize}

\subsection{Kiểm tra độ bền vững}

\textbf{Độ nhạy nhiễu:} Kiểm tra hiệu suất thuật toán dưới các mức nhiễu khác nhau:

\begin{equation}
x_{\text{noisy}} = x + \epsilon \quad \text{trong đó} \quad \epsilon \sim \mathcal{N}(0, \sigma^2)
\end{equation}

\textbf{Độ nhạy tham số:} Phân tích hiệu suất trên các thiết lập tham số khác nhau sử dụng grid search và phân tích độ nhạy.

\textbf{Kiểm tra khả năng mở rộng:} Đánh giá hiệu suất tính toán trên dataset có kích thước và chiều khác nhau.

\section{Cân nhắc đạo đức}

\subsection{Quyền riêng tư dữ liệu}

Tất cả dataset thực tế được sử dụng trong nghiên cứu này hoặc được công khai hoặc được ẩn danh hóa đúng cách. Chúng tôi đảm bảo tuân thủ các quy định bảo vệ dữ liệu có liên quan.

\subsection{Khả năng tái tạo}

Chúng tôi cam kết công khai code, dataset và cấu hình thí nghiệm để cho phép tái tạo và tạo thuận lợi cho nghiên cứu tương lai.

\section{Tóm tắt}

Chương này đã phác thảo phương pháp luận toàn diện được sử dụng trong nghiên cứu này. Cách tiếp cận của chúng tôi kết hợp phát triển lý thuyết với thiết kế thuật toán thực tế và đánh giá thực nghiệm nghiêm ngặt. Chương tiếp theo trình bày kết quả của việc áp dụng phương pháp luận này để điều tra phát hiện concept drift và thích ứng trên nhiều lĩnh vực và kịch bản.
