\chapter{Mô hình đề xuất}
\label{chap:proposed-model}

\textit{Trên cơ sở lý thuyết về ShapeDD và các phương pháp phát hiện trôi dạt đã trình bày ở Chương~\ref{chap:theoretical_foundation}, chương này đề xuất một hệ thống phát hiện và thích ứng concept drift toàn diện. Chúng tôi giới thiệu các cải tiến thuật toán nhằm tối ưu hóa hiệu suất tính toán và độ chính xác, đồng thời trình bày kiến trúc hệ thống xử lý luồng dữ liệu thời gian thực dựa trên Apache Kafka. Các đóng góp chính bao gồm: (1) Tích hợp Optimally-Weighted MMD (OW-MMD) để tăng tốc độ xử lý, (2) Xây dựng khung chiến lược thích ứng đa dạng dựa trên loại drift, và (3) Thiết kế kiến trúc hệ thống có khả năng mở rộng và chịu lỗi cao.}

\section{Động lực và tổng quan cách tiếp cận}

Mặc dù ShapeDD gốc thể hiện nhiều ưu điểm về độ chính xác định vị và khả năng khử nhiễu, việc áp dụng phương pháp này trong các hệ thống thời gian thực (real-time) quy mô lớn gặp phải hai thách thức chính:

\begin{enumerate}
    \item \textbf{Chi phí tính toán cao:} Việc sử dụng kiểm định hoán vị (permutation test) với số lượng lớn (thường là 2500 lần) để ước lượng p-value tạo ra nút thắt cổ chai về hiệu năng, giới hạn thông lượng (throughput) xử lý.
    \item \textbf{Độ nhạy với tham số:} Hiệu suất của ShapeDD phụ thuộc nhiều vào việc lựa chọn độ rộng hạt nhân (kernel bandwidth) và kích thước cửa sổ, làm giảm khả năng tổng quát hóa trên các luồng dữ liệu có đặc tính drift đa dạng.
    \item \textbf{Thiếu cơ chế thích ứng:} Phát hiện drift chỉ là bước đầu; hệ thống cần một cơ chế để tự động cập nhật mô hình một cách phù hợp với bản chất của sự thay đổi (đột ngột hay dần dần).
\end{enumerate}

Để giải quyết các thách thức trên, luận văn đề xuất mô hình \textbf{ShapeDD-Stream}, một hệ thống tích hợp bao gồm ba tầng xử lý chính:
\begin{itemize}
    \item \textbf{Tầng thuật toán:} Cải tiến ShapeDD bằng cách tích hợp \textit{Optimally-Weighted MMD (OW-MMD)} để giảm phương sai và chi phí tính toán, cùng với \textit{MMD-Agg} để tăng độ bền vững (robustness).
    \item \textbf{Tầng chiến lược:} Xây dựng khung thích ứng thông minh, sử dụng kết quả phân loại từ \textit{CDT\_MSW} để kích hoạt chiến lược cập nhật mô hình tối ưu (Reset, Incremental, hoặc Reuse).
    \item \textbf{Tầng kiến trúc:} Triển khai hệ thống trên nền tảng \textit{Apache Kafka}, đảm bảo khả năng xử lý luồng dữ liệu phân tán, độ trễ thấp và khả năng chịu lỗi.
\end{itemize}

\section{Cải tiến thuật toán phát hiện trôi dạt}

\subsection{Optimally-Weighted MMD (OW-MMD): Tối ưu hóa hiệu suất}
\label{sec:ow-mmd}

\subsubsection{Vấn đề của ước lượng MMD truyền thống}
Trong ShapeDD gốc, thống kê MMD được tính toán dựa trên trọng số đều (uniform weights), coi vai trò của mọi điểm dữ liệu trong cửa sổ là như nhau. Để đạt được độ tin cậy thống kê (statistical power) mong muốn, phương pháp này yêu cầu kích thước mẫu lớn hoặc quy trình kiểm định hoán vị tốn kém ($O(N_{perm} \cdot n^2)$). Điều này không phù hợp với các ứng dụng yêu cầu phản hồi tức thì.

\subsubsection{Giải pháp: Trọng số tối ưu giảm phương sai}
Nghiên cứu tích hợp phương pháp \textbf{OW-MMD} (Optimally-Weighted MMD) được đề xuất bởi Bharti et al.~\cite{bharti2023owmmd}. Thay vì sử dụng trọng số đều, OW-MMD gán trọng số cho các mẫu dữ liệu nhằm tối thiểu hóa phương sai của bộ ước lượng.

Công thức MMD bình phương có trọng số được định nghĩa lại như sau:
\begin{equation}
\text{MMD}^2_{\text{OW}} = \sum_{i,j} w^{XX}_{ij} k(x_i, x_j) + \sum_{i,j} w^{YY}_{ij} k(y_i, y_j) - 2\sum_{i,j} w^{XY}_{ij} k(x_i, y_j)
\end{equation}

Trong đó, trọng số $w_{ij}$ được tính toán dựa trên nguyên lý giảm phương sai: các điểm dữ liệu nằm trong vùng mật độ cao (có tổng độ tương đồng kernel lớn) sẽ được gán trọng số thấp hơn để giảm sự dư thừa thông tin, trong khi các điểm ở vùng biên hoặc vùng thưa thớt được gán trọng số cao hơn.
\begin{equation}
w_{ij} \propto \frac{1}{\sqrt{\sum_{k} k(x_i, x_k)}} \cdot \frac{1}{\sqrt{\sum_{k} k(x_j, x_k)}}
\end{equation}

\subsubsection{Quy trình phát hiện lai (Hybrid Detection Strategy)}
Để cân bằng giữa tốc độ và độ chính xác, chúng tôi đề xuất quy trình phát hiện hai giai đoạn cho ShapeDD\_OW\_MMD:

\begin{algorithm}[H]
\caption{ShapeDD\_OW\_MMD Hybrid Detection}
\begin{algorithmic}[1]
\REQUIRE Data buffer $W$, window sizes $l_1$, $l_2$
\ENSURE Drift detection results
\STATE \textbf{Giai đoạn 1: Phát hiện mẫu hình học nhanh (Fast Geometric Detection)}
\STATE Tính ma trận kernel $K$ cho cửa sổ $W$
\STATE Tính đường cong hình dạng $\sigma(t)$ thông qua tích chập (như ShapeDD gốc)
\STATE Xác định tập các điểm ứng viên $C = \{t \mid \text{zero-crossing}(\sigma'(t)) \land \sigma(t) > \text{threshold}\}$
\STATE
\STATE \textbf{Giai đoạn 2: Xác thực bằng OW-MMD (Validation)}
\FOR{mỗi điểm ứng viên $t_c \in C$}
    \STATE Chia cửa sổ $W$ thành $X_{ref}$ và $X_{test}$ tại điểm cắt $t_c$
    \STATE Tính thống kê $\text{MMD}^2_{\text{OW}}$ với trọng số tối ưu
    \STATE Ước lượng ngưỡng (threshold) $\tau$ thông qua bootstrap rút gọn ($N=10$)
    \IF{$\text{MMD}^2_{\text{OW}} > \tau$}
        \STATE Xác nhận drift tại $t_c$
        \RETURN \textbf{Drift Detected}
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

Cải tiến này giúp giảm số lượng mẫu bootstrap cần thiết từ 2500 xuống còn khoảng 10-50 mẫu mà vẫn duy trì độ chính xác tương đương, giúp tăng tốc độ xử lý lên đáng kể.

\subsection{MMD-Agg: Tăng cường độ bền vững}
\label{sec:mmdagg}

Một hạn chế khác của MMD là độ nhạy đối với việc lựa chọn tham số độ rộng kernel ($\sigma$). Nếu $\sigma$ quá nhỏ, MMD chỉ bắt được các thay đổi cục bộ; nếu quá lớn, nó có thể bỏ qua các chi tiết quan trọng.

Để khắc phục, chúng tôi tích hợp kỹ thuật \textbf{MMD-Agg} (MMD Aggregated)~\cite{schrab2023mmdagg}. Thay vì chọn một $\sigma$ cố định (thường dùng median heuristic), MMD-Agg tính toán MMD trên một tập hợp các bandwidths khác nhau {$\sigma_1, \sigma_2, \dots, \sigma_k$} và tổng hợp kết quả.

Quy trình này cho phép bộ phát hiện "nhìn" dữ liệu ở nhiều độ phân giải khác nhau, giúp phát hiện được cả các thay đổi nhỏ (cục bộ) và các thay đổi lớn (toàn cục) trong phân phối dữ liệu, làm tăng đáng kể độ chính xác (F1-score) trên các tập dữ liệu phức tạp.

\subsection{Tổng kết hiệu quả các cải tiến}

Bảng~\ref{tab:shapedd-improvements-summary} tóm tắt hiệu quả của các cải tiến đề xuất so với phương pháp gốc:

\begin{table}[H]
\centering
\caption{Tổng kết các cải tiến cho ShapeDD}
\label{tab:shapedd-improvements-summary}
\begin{tabular}{|l|p{4cm}|p{4cm}|p{3.5cm}|}
\hline
\textbf{Phương pháp} & \textbf{Vấn đề giải quyết} & \textbf{Kỹ thuật} & \textbf{Hiệu quả (Thực nghiệm)} \\
\hline
\textbf{OW-MMD} & Chi phí tính toán cao, thông lượng thấp & Variance-reduction weighting, giảm bootstrap & Tốc độ tăng $\approx 7\times$, F1 tăng +27.7\% \\
\hline
\textbf{MMD-Agg} & Độ nhạy với kernel bandwidth & Aggregated multi-kernel testing & F1 tăng +15.7\%, bền vững hơn \\
\hline
\end{tabular}
\end{table}

\section{Khung chiến lược thích ứng mô hình}
\label{sec:model-adaptation-framework}

Việc phát hiện drift chỉ có ý nghĩa khi hệ thống có hành động cụ thể để duy trì hiệu suất mô hình. Phần này trình bày khung chiến lược thích ứng (Adaptation Framework), liên kết kết quả phân loại loại drift từ CDT\_MSW (đã trình bày ở Chương 2) với các hành động cập nhật mô hình cụ thể.

\subsection{Ma trận quyết định chiến lược}

Thay vì áp dụng một chiến lược duy nhất (như huấn luyện lại toàn bộ) cho mọi trường hợp, hệ thống đề xuất sử dụng thông tin về loại drift để tối ưu hóa chi phí và hiệu suất. Bảng~\ref{tab:adaptation-strategies} mô tả ánh xạ giữa loại drift và chiến lược thích ứng:

\begin{table}[H]
\centering
\caption{Chiến lược thích ứng theo loại Drift}
\label{tab:adaptation-strategies}
\begin{tabular}{|l|p{5.5cm}|p{5cm}|}
\hline
\textbf{Loại Drift} & \textbf{Chiến lược Thích ứng} & \textbf{Cơ sở lý luận} \\
\hline
\textbf{Sudden} & \textbf{Full Model Reset:} Khởi tạo lại mô hình và huấn luyện lại trên cửa sổ dữ liệu mới nhất (post-drift). & Dữ liệu cũ không còn giá trị, cần loại bỏ hoàn toàn để tránh nhiễu (negative transfer). \\
\hline
\textbf{Incremental} & \textbf{Continuous Update:} Cập nhật mô hình hiện tại với dữ liệu mới (online learning/fine-tuning). & Sự thay đổi mang tính tiệm tiến, kiến thức cũ vẫn còn giá trị một phần. \\
\hline
\textbf{Gradual} & \textbf{Weighted Ensemble/Window:} Sử dụng cửa sổ trượt có trọng số, ưu tiên dữ liệu mới nhưng giữ lại một phần dữ liệu cũ. & Giai đoạn chuyển tiếp có sự pha trộn giữa hai phân phối, cần bộ nhớ đệm. \\
\hline
\textbf{Recurrent} & \textbf{Model Caching \& Reuse:} Tìm kiếm trong kho lưu trữ mô hình cũ phù hợp và kích hoạt lại. & Tái sử dụng tri thức đã học, tiết kiệm chi phí huấn luyện lại. \\
\hline
\textbf{Blip} & \textbf{No Action / Minimal Update:} Bỏ qua hoặc cập nhật với trọng số rất thấp. & Thay đổi chỉ là nhiễu tạm thời, tránh việc mô hình "quên" kiến thức ổn định. \\
\hline
\end{tabular}
\end{table}

\subsection{Triển khai các chiến lược}

\subsubsection{Chiến lược cho Sudden Drift (Trọng tâm nghiên cứu)}
Trong phạm vi luận văn, chiến lược cho \textit{Sudden Drift} được cài đặt và đánh giá chi tiết nhất. Quy trình cụ thể như sau:
\begin{enumerate}
    \item \textbf{Kích hoạt:} Khi CDT\_MSW phân loại drift là "Sudden".
    \item \textbf{Thu thập dữ liệu:} Hệ thống chờ và thu thập một lượng dữ liệu mới ($N_{new}$) ngay sau điểm drift.
    \item \textbf{Huấn luyện lại:} Một instance mô hình mới (ví dụ: Logistic Regression) được khởi tạo với trọng số ngẫu nhiên và huấn luyện trên $N_{new}$.
    \item \textbf{Thay thế:} Mô hình cũ bị loại bỏ hoàn toàn, mô hình mới được đưa vào sử dụng (hot-swap).
\end{enumerate}

\subsubsection{Cơ chế Model Caching cho Recurrent Drift}
Để xử lý drift lặp lại, hệ thống duy trì một \textit{Model Repository}. Mỗi khi một mô hình bị thay thế (do drift), nó được lưu lại cùng với "chữ ký" phân phối (distribution signature) của dữ liệu mà nó đã học.
\begin{itemize}
    \item \textbf{Signature:} Vector trung bình và ma trận hiệp phương sai của đặc trưng.
    \item \textbf{Matching:} Khi drift xảy ra, hệ thống so sánh phân phối dữ liệu mới với các signature trong kho bằng khoảng cách Kolmogorov-Smirnov (KS). Nếu độ tương đồng cao (khoảng cách nhỏ hơn ngưỡng $\epsilon$), mô hình cũ sẽ được tải lại và tinh chỉnh nhẹ.
\end{itemize}

\subsubsection{Cơ chế Meta-Learning (Hướng phát triển)}
Hệ thống được thiết kế để hỗ trợ Meta-Learning trong tương lai: một mô hình cấp cao (meta-learner) sẽ học cách chọn chiến lược tốt nhất dựa trên lịch sử các lần thích ứng thành công hay thất bại, thay vì chỉ dựa vào quy tắc cố định.

\section{Kiến trúc hệ thống Streaming Real-time với Apache Kafka}

Để hiện thực hóa các phương pháp trên trong môi trường thực tế, luận văn xây dựng một kiến trúc xử lý luồng dữ liệu phân tán dựa trên Apache Kafka. Kiến trúc này đảm bảo tính tách biệt (decoupling), khả năng mở rộng (scalability) và độ tin cậy (reliability).

\subsection{Tổng quan kiến trúc}

Hệ thống được thiết kế theo mô hình \textbf{Event-Driven Architecture} gồm 5 thành phần chính hoạt động độc lập và giao tiếp qua các Kafka topics:

\begin{figure}[h]
\centering
% Placeholder for Architecture Diagram
\includegraphics[width=0.95\textwidth]{image/snr_adaptive_architecture.png} 
\caption{Sơ đồ kiến trúc hệ thống phát hiện và thích ứng Drift}
\label{fig:system_architecture}
\end{figure}

\begin{enumerate}
    \item \textbf{Data Producer (Nguồn dữ liệu):} Mô phỏng hoặc thu thập dữ liệu từ cảm biến/nguồn phát, gửi vào topic \texttt{sensor.stream}.
    \item \textbf{Drift Detection Consumer (Bộ phát hiện):} Đọc dữ liệu từ stream, duy trì cửa sổ trượt và thực thi thuật toán ShapeDD\_OW\_MMD.
    \item \textbf{Drift Classifier (Bộ phân loại):} Được kích hoạt khi có tín hiệu drift, thực thi CDT\_MSW để xác định loại drift và gửi sự kiện vào topic \texttt{drift.results}.
    \item \textbf{Adaptation Manager (Bộ thích ứng):} Lắng nghe sự kiện drift, thực thi chiến lược thích ứng (huấn luyện lại/cập nhật) và publish mô hình mới.
    \item \textbf{Monitoring Dashboard:} Trực quan hóa dữ liệu, điểm drift và hiệu suất mô hình theo thời gian thực.
\end{enumerate}

\subsection{Thiết kế chi tiết các thành phần}

\subsubsection{Producer và Data Ingestion}
Producer được thiết kế để chịu lỗi và đảm bảo tính toàn vẹn dữ liệu:
\begin{itemize}
    \item Sử dụng cơ chế \textbf{retry with exponential backoff} để xử lý mất kết nối mạng.
    \item Dữ liệu được serialize dưới dạng JSON bao gồm timestamp, feature vector và metadata.
    \item Hỗ trợ điều chỉnh tốc độ phát tin (throughput control) để mô phỏng các tải hệ thống khác nhau.
\end{itemize}

\subsubsection{Consumer và Cơ chế Windowing}
Thành phần Consumer đóng vai trò quan trọng nhất, thực hiện phát hiện drift:
\begin{itemize}
    \item \textbf{Circular Buffer:} Duy trì một bộ đệm tuần hoàn (ví dụ: 1000 mẫu) trong bộ nhớ để phục vụ tính toán cửa sổ trượt mà không cần truy xuất lại Kafka quá nhiều.
    \item \textbf{4-Phase Lifecycle:}
        \begin{enumerate}
            \item \textit{Pre-training:} Thu thập dữ liệu ban đầu để huấn luyện mô hình gốc.
            \item \textit{Warm-up:} Giai đoạn ổn định, thiết lập baseline hiệu suất.
            \item \textit{Monitoring (Frozen):} Mô hình chạy ở chế độ dự đoán (không học), liên tục kiểm tra drift bằng ShapeDD.
            \item \textit{Adaptation:} Tạm dừng monitoring để cập nhật mô hình khi có drift.
        \end{enumerate}
\end{itemize}

\subsubsection{Quản lý Topic và Giao tiếp}
Hệ thống sử dụng các topic riêng biệt để phân tách luồng dữ liệu và luồng điều khiển:
\begin{table}[H]
\centering
\caption{Danh sách Kafka Topics và Chức năng}
\label{tab:kafka-topics}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Topic Name} & \textbf{Nội dung} & \textbf{Mục đích} \\
\hline
\texttt{sensor.stream} & Raw data samples & Luồng dữ liệu đầu vào cho mô hình và detector. \\
\hline
\texttt{drift.results} & Drift events & Thông báo drift đã được phát hiện và phân loại. \\
\hline
\texttt{model.updated} & Model metadata & Thông báo mô hình mới đã sẵn sàng (hot-reload). \\
\hline
\texttt{model.accuracy} & Performance metrics & Dữ liệu giám sát độ chính xác real-time. \\
\hline
\end{tabular}
\end{table}

\section{Cơ chế chịu lỗi và đảm bảo độ tin cậy}

Trong môi trường phân tán, các sự cố là không thể tránh khỏi. Hệ thống đề xuất tích hợp các cơ chế chịu lỗi (Fault Tolerance) ở nhiều cấp độ:

\subsection{Xử lý lỗi ở mức ứng dụng}
\begin{itemize}
    \item \textbf{Graceful Degradation:} Nếu module Adaptor gặp lỗi (ví dụ: tràn bộ nhớ khi huấn luyện), hệ thống sẽ fallback về mô hình cũ và ghi log cảnh báo, thay vì dừng toàn bộ pipeline.
    \item \textbf{Try-Catch Wrapper:} Quá trình tính toán ShapeDD được bọc trong các khối an toàn để xử lý các ngoại lệ số học (như ma trận không nghịch đảo) mà không làm crash Consumer.
\end{itemize}

\subsection{Xử lý lỗi ở mức hạ tầng (Kafka)}
\begin{itemize}
    \item \textbf{Replication:} Các topic quan trọng được cấu hình \texttt{replication.factor=3} để đảm bảo không mất dữ liệu ngay cả khi 1-2 broker bị lỗi.
    \item \textbf{Offset Management:} Consumer chỉ commit offset sau khi đã xử lý xong batch dữ liệu, đảm bảo ngữ nghĩa "at-least-once" (không bỏ sót dữ liệu).
    \item \textbf{Consumer Rebalancing:} Nếu một instance của Consumer bị lỗi, Kafka sẽ tự động phân phối lại các partition cho các consumer còn lại trong nhóm.
\end{itemize}

\section{Kết luận chương}
Chương này đã trình bày chi tiết mô hình đề xuất \textbf{ShapeDD-Stream}, một giải pháp toàn diện cho bài toán concept drift. Bằng cách kết hợp các cải tiến thuật toán (OW-MMD, MMD-Agg) với một kiến trúc hệ thống hiện đại (Kafka, Microservices) và chiến lược thích ứng thông minh, mô hình hứa hẹn giải quyết được các hạn chế về hiệu suất và khả năng thực thi của các phương pháp trước đây. Chương tiếp theo sẽ trình bày các thực nghiệm và đánh giá chi tiết để kiểm chứng hiệu quả của mô hình này.
